<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[人到中年]]></title>
      <url>https://jiechengyang.github.io/2019/10/10/mid-age/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本来文章起名是叫“中年危机”的。思考了一下觉得不妥，“中年”不一定危机呢。“人到中年”像是一句还没说完的话，人到中年会怎么样呢？不同的人有不同的答案，把这个思考留给大家吧。</p>
</blockquote>
<p>你觉得 人到中年 应该是怎么样的生活和状态呢？</p>
<p>我不是一个喜欢喜欢贩卖焦虑的人，甚至很讨厌。因为生活已经很难了；</p>
<p>但这个世界，这个社会，这个环境，周边的人，总会漫不经心的触碰到你。</p>
<p>要对未来充满自信和希望。</p>
]]></content>
      
        <categories>
            
            <category> 综合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> essay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【转】如何优雅处理前端异常]]></title>
      <url>https://jiechengyang.github.io/2019/05/01/js-exception-handing/</url>
      <content type="html"><![CDATA[<p>前端一直是距离用户最近的一层，随着产品的日益完善，我们会更加注重用户体验，而前端异常却如鲠在喉，甚是烦人。</p>
<h1 id="一、为什么要处理异常？"><a href="#一、为什么要处理异常？" class="headerlink" title="一、为什么要处理异常？"></a>一、为什么要处理异常？</h1><p id="div-border-left-green">异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。</p>

<p>1.增强用户体验；<br>2.远程定位问题；<br>3.未雨绸缪，及早发现问题；<br>4.无法复线问题，尤其是移动端，机型，系统都是问题；<br>5.完善的前端方案，前端监控系统；</p>
<a id="more"></a>
<p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<h1 id="二、需要处理哪些异常？"><a href="#二、需要处理哪些异常？" class="headerlink" title="二、需要处理哪些异常？"></a>二、需要处理哪些异常？</h1><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p>
<ul>
<li>JS 语法错误、代码异常</li>
<li>AJAX 请求异常</li>
<li>静态资源加载异常</li>
<li>Promise 异常</li>
<li>Iframe 异常</li>
<li>跨域 Script error</li>
<li>崩溃和卡顿</li>
</ul>
<p id="div-border-left-yellow">下面我会针对每种具体情况来说明如何处理这些异常。</p>


<h1 id="三、Try-Catch-的误区"><a href="#三、Try-Catch-的误区" class="headerlink" title="三、Try-Catch 的误区"></a>三、Try-Catch 的误区</h1><p id="div-border-top-blue"><code>try-catch</code> 只能捕获到 <font color="red"><strong>同步</strong></font> 的运行时错误，对 <font color="red">语法</font> 和 <font color="red">异步</font> 错误却无能为力，捕获不到。【不能捕获XHR，AJAX的异常】</p>

<p>1.同步运行时错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'jartto'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(nam);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： <span class="built_in">ReferenceError</span>: nam is not defined at &lt;anonymous&gt;:<span class="number">3</span>:<span class="number">15</span></span><br></pre></td></tr></table></figure></p>
<p>2.不能捕获到语法错误，我们修改一下代码，删掉一个单引号：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'jartto;</span></span><br><span class="line"><span class="string">  console.log(nam);</span></span><br><span class="line"><span class="string">&#125; catch(e) &#123;</span></span><br><span class="line"><span class="string">  console.log('</span>捕获到异常：<span class="string">',e);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>
<blockquote>
<font color="#0e8a16">不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境吧。?</font>
</blockquote>
<p>3.异步错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>.map(<span class="function"><span class="params">v</span> =&gt;</span> v);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看日志：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: Cannot read property <span class="string">'map'</span> <span class="keyword">of</span> <span class="literal">undefined</span> at setTimeout (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>:3:11)</span></span><br></pre></td></tr></table></figure></p>
<p>并没有捕获到异常，这是需要我们特别注意的地方。<font color="#b60205">【try catch 无法捕获异步异常】</font></p>
<h1 id="四、window-onerror-不是万能的"><a href="#四、window-onerror-不是万能的" class="headerlink" title="四、window.onerror 不是万能的"></a>四、window.onerror 不是万能的</h1><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 <code>window.onerror()</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>message    错误信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;String&#125;</span>  </span>source    出错文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>lineno    行号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Number&#125;</span>  </span>colno    列号</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;Object&#125;</span>  </span>error  Error对象（对象）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.首先试试同步运行时错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line"><span class="comment">// message：错误信息（字符串）。</span></span><br><span class="line"><span class="comment">// source：发生错误的脚本URL（字符串）</span></span><br><span class="line"><span class="comment">// lineno：发生错误的行号（数字）</span></span><br><span class="line"><span class="comment">// colno：发生错误的列号（数字）</span></span><br><span class="line"><span class="comment">// error：Error对象（对象）</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">Jartto;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们捕获到了异常：<br><img src="/images/js-exception-handing-1.png" alt></p>
<p>2.再试试语法错误呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'Jartto</span></span><br></pre></td></tr></table></figure></p>
<p>控制台打印出了这样的异常：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">SyntaxError</span>: Invalid or unexpected token</span><br></pre></td></tr></table></figure></p>
<p id="div-border-top-red">什么，竟然没有捕获到语法错误？!!</p>

<p>3.怀着忐忑的心，我们最后来试试异步运行时错误：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>控制台输出了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">捕获到异常： &#123;<span class="attr">message</span>: <span class="string">"Uncaught ReferenceError: Jartto is not defined"</span>, </span><br><span class="line">  source: <span class="string">"http://127.0.0.1:8001/"</span>, </span><br><span class="line">  lineno: <span class="number">36</span>, <span class="attr">colno</span>: <span class="number">5</span>, </span><br><span class="line">  error: <span class="built_in">ReferenceError</span>: Jartto is not defined at setTimeout (http:<span class="comment">//127.0.0.1:8001/:36:5)&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>4.接着，我们试试网络请求异常的情况：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="./</span>jartto.png<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p id="div-border-left-red">我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p>

<p>补充一点：<code>window.onerror</code> 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 <code>Uncaught Error: xxxxx</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  Jartto;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>控制台就不会再有这样的错误了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">ReferenceError</span>: Jartto is not defined</span><br><span class="line">    at setTimeout ((index):<span class="number">36</span>)</span><br></pre></td></tr></table></figure></p>
<font color="#ff8f00">需要注意：</font>

<ul>
<li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li>
<li>onerror 无法捕获语法错误；</li>
</ul>
<p id="div-border-top-red">到这里基本就清晰了：在实际的使用过程中，<code>onerror</code> 主要是来捕获预料之外的错误，而 <code>try-catch</code> 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>

<p id="div-border-left-yellow">问题又来了，捕获不到静态资源加载异常怎么办？</p>

<h1 id="五、window-addEventListener"><a href="#五、window-addEventListener" class="headerlink" title="五、window.addEventListener"></a>五、window.addEventListener</h1><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 <code>onerror()</code> 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的 <code>window.addEventListener</code> 捕获。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;scritp&gt;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;img src="./</span>jartto.png<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><img src="/images/js-exception-handing-2.png" alt></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<font color="red">需要注意：</font>

<ul>
<li>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。</li>
<li>需要注意避免 addEventListener 重复监听。</li>
</ul>
<h1 id="六、Promise-Catch"><a href="#六、Promise-Catch" class="headerlink" title="六、Promise Catch"></a>六、Promise Catch</h1><p id="div-border-top-blue">在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。</p>

<p>没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p>
<p>解决方案： 为了防止有漏掉的 Promise 异常，建议在全局增加一个对 <code>unhandledrejection</code>的监听，用来全局监听 <code>Uncaught Promise Error</code>。使用方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们继续来尝试一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'promise error'</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到如下输出：<br><img src="/images/js-exception-handing-3.png" alt></p>
<p>那如果对 Promise 不进行 catch 呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'jartto: promise error'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>嗯，事实证明，也是会被正常捕获到的。</p>
<p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 <code>unhandledrejection</code> 的监听，用来全局监听 <code>Uncaught Promise Error</code>。</p>
<p>补充一点：如果去掉控制台的异常显示，需要加上：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure></p>
<h1 id="七、VUE-errorHandler"><a href="#七、VUE-errorHandler" class="headerlink" title="七、VUE errorHandler"></a>七、VUE errorHandler</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过vue errorHandler捕获的错误'</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  <span class="built_in">console</span>.error(vm);</span><br><span class="line">  <span class="built_in">console</span>.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、React-异常捕获"><a href="#八、React-异常捕获" class="headerlink" title="八、React 异常捕获"></a>八、React 异常捕获</h1><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我们可以了解一下：<code>error boundary</code><br>UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。</p>
<p id="div-border-left-red">需要注意的是： error boundaries 并不会捕捉下面这些错误。</p>

<p>1.事件处理器<br>2.异步代码<br>3.服务端的渲染代码<br>4.在 error boundaries 区域内的错误</p>
<p>我们来举一个小例子，在下面这个 <code>componentDIdCatch(error,info)</code> 里的类会变成一个 <code>error boundary</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们像使用普通组件那样使用它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;<span class="regexp">/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>componentDidCatch()</code> 方法像 JS 的 <code>catch{}</code> 模块一样工作，但是对于组件，只有 class 类型的组件<code>( class component )</code>可以成为一个 <code>error boundaries</code>。</p>
<p>实际上，大多数情况下我们可以在整个程序中定义一个 <code>error boundary</code>组件，之后就可以一直使用它了！</p>
<h1 id="九、iframe-异常"><a href="#九、iframe-异常" class="headerlink" title="九、iframe 异常"></a>九、iframe 异常</h1><p>对于 iframe 的异常捕获，我们还得借力 <code>window.onerror</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'捕获到异常：'</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个简单的例子可能如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"./iframe.html"</span> frameborder=<span class="string">"0"</span>&gt;&lt;<span class="regexp">/iframe&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  window.frames[0].onerror = function (message, source, lineno, colno, error) &#123;</span></span><br><span class="line"><span class="regexp">    console.log('捕获到 iframe 异常：',&#123;message, source, lineno, colno, error&#125;);</span></span><br><span class="line"><span class="regexp">    return true;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="十、Script-error"><a href="#十、Script-error" class="headerlink" title="十、Script error"></a>十、Script error</h1><p>一般情况，如果出现 <code>script error</code> 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p>
<p id="div-border-left-blue">跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://jartto.wang/main.js"</span> crossorigin&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者动态去添加 js 脚本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.crossOrigin = <span class="string">'anonymous'</span>;</span><br><span class="line">script.src = url;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure></p>
<p id="div-border-left-yellow">特别注意，服务器端需要设置：Access-Control-Allow-Origin </p>

<p>此外，我们也可以试试这个 - <a href="https://juejin.im/post/5c00a405f265da610e7fd024" target="_blank" rel="noopener">解决 Script Error 的另类思路</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrappedListener = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> originAddEventListener.call(<span class="keyword">this</span>, type, wrappedListener, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下：</p>
<ul>
<li>改写了 EventTarget 的 addEventListener 方法；</li>
<li>对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；</li>
<li>浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；</li>
<li>重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；</li>
</ul>
<p>利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> originAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">   EventTarget.prototype.addEventListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, options</span>) </span>&#123;</span><br><span class="line">+    <span class="comment">// 捕获添加事件时的堆栈</span></span><br><span class="line">+    <span class="keyword">const</span> addStack = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Event (<span class="subst">$&#123;type&#125;</span>)`</span>).stack;</span><br><span class="line">     <span class="keyword">const</span> wrappedListener = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> listener.apply(<span class="keyword">this</span>, args);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">+        <span class="comment">// 异常发生时，扩展堆栈</span></span><br><span class="line">+        err.stack += <span class="string">'\n'</span> + addStack;</span><br><span class="line">         <span class="keyword">throw</span> err;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> originAddEventListener.call(<span class="keyword">this</span>, type, wrappedListener, options);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)();</span><br></pre></td></tr></table></figure></p>
<h1 id="十一、崩溃和卡顿"><a href="#十一、崩溃和卡顿" class="headerlink" title="十一、崩溃和卡顿"></a>十一、崩溃和卡顿</h1><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p>
<blockquote>
<p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p>
</blockquote>
<p>1.利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控。<br>不错的文章，推荐阅读：<a href="http://jasonjl.me/blog/2015/06/21/taking-action-on-browser-crashes/" target="_blank" rel="noopener">Logging Information on Browser Crashes</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">'good_exit'</span>, <span class="string">'pending'</span>);</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      sessionStorage.setItem(<span class="string">'time_before_crash'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().toString());</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'beforeunload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sessionStorage.setItem(<span class="string">'good_exit'</span>, <span class="string">'true'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span>(sessionStorage.getItem(<span class="string">'good_exit'</span>) &amp;&amp;</span><br><span class="line">  sessionStorage.getItem(<span class="string">'good_exit'</span>) !== <span class="string">'true'</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      insert crash logging code here</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  alert(<span class="string">'Hey, welcome back from your crash, looks like you crashed on: '</span> + sessionStorage.getItem(<span class="string">'time_before_crash'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.基于以下原因，我们可以使用 <code>Service Worker</code> 来实现 <a href="https://juejin.im/entry/5be158116fb9a049c6434f4a?utm_source=gold_browser_extension" target="_blank" rel="noopener">网页崩溃的监控</a>：</p>
<ul>
<li>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；</li>
<li>Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；</li>
<li>网页可以通过 <code>navigator.serviceWorker.controller.postMessage</code> API 向掌管自己的 SW 发送消息。</li>
</ul>
<h1 id="十二、错误上报"><a href="#十二、错误上报" class="headerlink" title="十二、错误上报"></a>十二、错误上报</h1><p>1.通过 Ajax 发送数据<br>因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p>
<p>2.动态创建 img 标签的形式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">report</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reportUrl = <span class="string">'http://jartto.wang/report'</span>;</span><br><span class="line">  <span class="keyword">new</span> Image().src = <span class="string">`<span class="subst">$&#123;reportUrl&#125;</span>?logs=<span class="subst">$&#123;error&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reporter.send = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只采集 30%</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Math</span>.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">    send(data)      <span class="comment">// 上报错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。<font color="red">【这个随机数用的不错！】</font></p>
<h1 id="十三、总结"><a href="#十三、总结" class="headerlink" title="十三、总结"></a>十三、总结</h1><p id="div-border-left-yellow">回到我们开头提出的那个问题，如何优雅的处理异常呢？</p>

<p>1.可疑区域增加 Try-Catch<br>2.全局监控 JS 异常 window.onerror<br>3.全局监控静态资源异常 window.addEventListener<br>4.捕获没有 Catch 的 Promise 异常：unhandledrejection<br>5.VUE errorHandler 和 React componentDidCatch<br>6.监控网页崩溃：window 对象的 load 和 beforeunload<br>7.跨域 crossOrigin 解决</p>
<p>其实很简单，正如本文所说：采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p>
<p><a href="http://jartto.wang/2018/11/20/js-exception-handling/" target="_blank" rel="noopener">原文</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你 Vue 服务端渲染]]></title>
      <url>https://jiechengyang.github.io/2019/03/31/vue-ssr/</url>
      <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>在写这篇文章之前，我有写一篇 <a href="https://neveryu.github.io/2018/06/18/vue-prerender/" target="_blank" rel="noopener">Vue 预渲染的教程</a> 以及 <a href="https://neveryu.github.io/prerender-website/index.html" target="_blank" rel="noopener">在线示例</a>，有需要的可以看一下~</p>
<hr>
<font color="green">【下面开始 Vue 服务端渲染】</font>

<a id="more"></a>
<p>服务端渲染 = SSR = Server-Side Rendering</p>
<p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue 服务器渲染</a> 可以说是我们学习 Vue 技术的最后一个环节了；也是上手难度稍为高一点的一个环节。</p>
<p>目前还没有发现很好的学习资料或者教程，文档也不是特别明白，这也导致了很多人没能拿下 vue 的 ssr。</p>
<p>所以就想着写一个曲线平滑，循序渐进，明了易懂的 <a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="noopener">教程</a> 来帮助大家找到 Vue SSR 的感觉。</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><font color="red">由于内容较多，如果只写一篇文章就想把 Vue SSR 介绍清晰透彻的话，我觉得不太现实；</font>所以就想着把一个完整的 Vue SSR 项目细分开来，每一个小节讲解一个知识点，这样效果应该会好一点吧。这个项目虽然不大，但已经包含了 Vue SSR 的所有内容。</p>
<p id="div-border-top-green">项目仓库：<a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="noopener">https://github.com/Neveryu/vue-ssr-lessons</a><br></p>

<p>1、<a href="https://github.com/Neveryu/vue-ssr-lessons" target="_blank" rel="noopener">这个教程</a> 分为 7 个小节，每个小节都是一个独立的可以运行的小项目，这样可以减少大家出错的概率（如果只给出最终的代码，那万一又跑不起来，岂不凉凉，影响大家学习的心情）；每个小节简单配备了 <strong>运行步骤</strong> 以及 <strong>简要说明</strong> 来帮助大家运行项目以及了解本节的知识点。</p>
<p><img src="/images/vue-ssr-1.png" alt></p>
<p>2、其次，每个小节都是在前一小节的基础上，继续补充写代码的，这样，大家对比就能知道，这一节具体增加了哪些代码，哪些内容；方便大家学习某一个小节的知识（如果笼统的一次性给出最终代码，这样在找代码之间逻辑关系时，比较吃力）</p>
<h1 id="章节介绍"><a href="#章节介绍" class="headerlink" title="章节介绍"></a>章节介绍</h1><p>第一节：一个最简单的服务端渲染原型（10 行代码）【难度：<i class="fa fa-star"></i>】<br>第二节：与服务器集成，使用 Express 作为服务器提供服务【难度：<i class="fa fa-star"></i>】<br>第三节：使用一个页面模版【难度：<i class="fa fa-star"></i>】<br>第四节：开发客户端与服务端入口文件，配置webpack【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第五节：使用vue-router来做路由【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第六节：数据，vuex，状态容器【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>】<br>第七节：增加一些额外的功能，完善项目【难度：<i class="fa fa-star"></i><i class="fa fa-star"></i>】</p>
<h1 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h1><p>1、建议你先看一遍 Vue SSR 的文档，<em>看不懂的地方不要慌，留个印象也行</em><br>2、学习这个课程的时候，打开 Vue SSR 的文档；找到当前这一小节对应文档中的文字介绍部分<br>3、如果你基础有点薄弱的话，不要太过于着急<br>4、不能保证所有人看一遍就能学会，但是能保证所有人，两遍能拿下<br>5、如果你能跟着动手敲的话，将会事半功倍</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p><strong>1、避免单例状态</strong><br>在 <code>app.js</code> 中，暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例。</p>
<p><a href="https://ssr.vuejs.org/zh/guide/structure.html#%E9%81%BF%E5%85%8D%E7%8A%B6%E6%80%81%E5%8D%95%E4%BE%8B" target="_blank" rel="noopener">相关文档</a></p>
<p><img src="/images/vue-ssr-2.png" alt></p>
<p><strong>2、配置webpack</strong><br><code>webpack</code> 配置文件包含：基本配置(base config)、客户端配置(client config)、服务器配置(server config)。<br>基本配置包含两个环境（客户端环境，服务器环境）共享的配置；然后客户端配置和服务器配置都会通过使用 <code>webpack-merge</code> 来简单的扩展基本配置。</p>
<p><a href="https://ssr.vuejs.org/zh/guide/build-config.html" target="_blank" rel="noopener">相关文档</a></p>
<blockquote>
<p>教程中的 webpack 相关的配置已经配置好了，你可以直接全部拿过来用就行了</p>
</blockquote>
<p><strong>3、createBundleRenderer</strong><br>我们在前三节使用的都是 <code>vue-server-renderer</code> 中的 <code>createRenderer</code> 方法；从第四节开始，我们使用的是 <code>createBundleRenderer</code>，所创建的 <code>bundle renderer</code>，用法和普通 <code>renderer</code> 相同。 <code>createBundleRenderer</code> 接收一个 <code>server bundle</code> 生成的特殊 <code>JSON</code> 文件。但是 <code>bundle renderer</code> 提供以下优点：</p>
<ul>
<li>内置的 <code>source map</code> 支持（在 <code>webpack</code> 配置中使用 <code>devtool: &#39;source-map&#39;</code>）</li>
<li>在开发环境甚至部署过程中热重载（通过读取更新后的 <code>bundle</code>，然后重新创建 <code>renderer</code> 实例）</li>
<li>关键 <code>CSS(critical CSS)</code> 注入（在使用 <code>*.vue</code> 文件时）：自动内联在渲染过程中用到的组件所需的 <code>CSS</code>。更多细节请查看 <code>CSS</code> 章节。</li>
<li>使用 <code>clientManifest</code> 进行资源注入：自动推断出最佳的预加载(<code>preload</code>)和预取(<code>prefetch</code>)指令，以及初始渲染所需的代码分割 <code>chunk</code>。</li>
</ul>
<p><a href="https://ssr.vuejs.org/zh/guide/bundle-renderer.html" target="_blank" rel="noopener">相关文档</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Travis CI 自动更新 GitHub Pages]]></title>
      <url>https://jiechengyang.github.io/2019/02/05/travis-ci/</url>
      <content type="html"><![CDATA[<p><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 提供的是持续集成服务（Continuous Integration，简称 CI）。我们在软件开发过程中，有构建、测试、部署这些必不可少的步骤，而这些会花掉我们很多的时间。为了提高软件开发的效率，现在涌现了很多自动化工具。<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 是目前<a href="https://github.blog/2017-11-07-github-welcomes-all-ci-tools/" target="_blank" rel="noopener">市场份额</a>最大的一个，而且有很详细的文档以及可以和 Github 很好的对接。</p>
<a id="more"></a>
<p>Travis CI 还是很强大的，用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化。</p>
<p>就我写的 <a href="https://neveryu.github.io/web-bookmarks/" target="_blank" rel="noopener">web-bookmarks</a> 这个项目来说的话，每次更改完都要手动部署到 GitHub Pages。</p>
<p>从最开始的手动构建部署：手动敲构建命令，然后手动推到 GitHub。(<em>重复的次数多了就显得很麻烦，出错的几率也会变大。</em>)</p>
<p>后来写了一个构建部署的脚本：每次开发完，再手动执行脚本，完成构建部署。</p>
<p>再到现在的使用 CI 自动更新：开发完，我只用将源码 push 到 GitHub 做版本管理，就 ok 了；Travis 监测到代码有变化，然后就会自动执行我们设定好的任务。【优秀～】</p>
<h1 id="一、什么是持续集成"><a href="#一、什么是持续集成" class="headerlink" title="一、什么是持续集成"></a>一、什么是持续集成</h1><p>Travis CI 提供的持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>
<p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。</p>
<p id="div-border-top-purple">举一个例子：我们可以在我们的开源项目中，安排一个代码格式检查和测试的任务 <code>npm run test</code>，不管是自己提交代码，还是别人提交的 PR，Travis 监测到代码有新的内容，都会来执行这个任务。【不管代码写的怎样，格式一定不能乱～，哈哈😄】<br></p>

<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>
<h1 id="二、开始使用"><a href="#二、开始使用" class="headerlink" title="二、开始使用"></a>二、开始使用</h1><p>首先打开官方网站 <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci.org</a>，然后使用 Github 账号登入 Travis CI，然后 Travis 中会列出你 Github 上面所有的仓库，以及你所属于的组织。</p>
<p>然后，勾选你需要 Travis 帮你自动构建的仓库，打开仓库旁边的开关，打开以后，Travis 就会监听这个仓库的所有变化了。</p>
<p><img src="/images/travis-ci-1.png" alt="travis-ci-1"></p>
<h1 id="三、-travis-yml"><a href="#三、-travis-yml" class="headerlink" title="三、.travis.yml"></a>三、.travis.yml</h1><p>Travis 要求项目的根目录下面，必须有一个 <code>.travis.yml</code> 文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 <code>Commit</code>，Travis 就会去找这个文件，执行里面的命令。</p>
<p>所以呢，我们就可以在这个文件里，配置我们任务（Travis 监测到仓库有 <code>commit</code> 后会自动执行）。</p>
<p>一个简单的 <code>.travis.yml</code> 文件如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">script:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>所以呢，我在 <code>.travis.yml</code> 里，配置了一个执行脚本的任务；那么现在 Travis 监测到我仓库有 <code>commit</code> 后就会找到 <code>.travis.yml</code> 这个文件，然后就执行了我的那个脚本了。</p>
<h2 id="install-字段"><a href="#install-字段" class="headerlink" title="install 字段"></a>install 字段</h2><p><code>install</code> 字段用来指定安装脚本，如果有多个脚本，可以写成下面的形式。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，如果 <code>command1</code> 失败了，整个构建就会停下来，不再往下进行<br>如果不需要安装，即跳过安装阶段，就直接设为 <code>true</code>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="script-字段"><a href="#script-字段" class="headerlink" title="script 字段"></a>script 字段</h2><p><code>script</code> 字段用来配置构建或者测试脚本，如果有多个脚本，可以写成下面的形式。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p>
<p>注意，<code>script</code> 与 <code>install</code> 不一样，如果 <code>command1</code> 失败，<code>command2</code> 会继续执行。但是，整个构建阶段的状态是失败。</p>
<p>如果 <code>command2</code> 只有在 <code>command1</code> 成功后才能执行，就要写成下面这样。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span> <span class="string">command1</span> <span class="string">&amp;&amp;</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="四、部署时面临的问题"><a href="#四、部署时面临的问题" class="headerlink" title="四、部署时面临的问题"></a>四、部署时面临的问题</h1><p id="div-border-left-red">现在脚本是由 Travis CI 来执行的，部署的时候，怎么让 Travis 有权限往 Github 提交代码呢？</p>

<p>Github 有提供一个 <a href="https://github.blog/2013-05-16-personal-api-tokens/" target="_blank" rel="noopener">Personal access tokens</a>，这个 Token 与 账号密码 以及 SSH Keys 同样具有 Github 写入能力。</p>
<p>前往 Github 帐号 Settings 页面，在左侧选择 <code>Personal Access Token</code>，然后在右侧面板点击 <code>“Generate new token”</code> 来新建一个 Token。需要注意的是，创建完的 Token 只有第一次可见，之后再访问就无法看见（只能看见他的名称），因此要保存好这个值。</p>
<p><img src="/images/travis-ci-2.png" alt="travis-ci-2"></p>
<p>那么，这个 Token 怎么使用呢。</p>
<h2 id="方案一、"><a href="#方案一、" class="headerlink" title="方案一、"></a>方案一、</h2><p>一个比较方便快捷的方式，是通过 Travis 网站，写在每个仓库的设置页面里，有一个 <code>Environment Variables</code> 的配置项，给我们的 Token 起一个名字 <code>gh_token</code> 添加进去。这样以来，脚本内部就可以使用这个环境变量了。<br><img src="/images/travis-ci-3.png" alt="travis-ci-1"><br>你可以在你脚本内部使用 <code>${gh_token}</code> 的形式来使用这个 Token 了。【当然了，你还可以添加其他的环境变量进去。】【<a href="https://docs.travis-ci.com/user/environment-variables" target="_blank" rel="noopener">官方文档在这里</a>】</p>
<p>使用 <code>Personal access tokens</code> 向 GitHub 提交代码的命令格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;GH_TOKEN&#125; 对应就是 Personal access tokens ， GH_TOKEN 是环境变量名</span></span><br><span class="line"><span class="comment"># $&#123;GH_REF&#125; 对应的是你的 Github 仓库地址，GH_REF 是变量名</span></span><br><span class="line">git push -f <span class="string">"https://<span class="variable">$&#123;GH_TOKEN&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:gh-pages</span><br></pre></td></tr></table></figure></p>
<p id="div-border-left-green">这里需要注意的是：<br>1、GitHub 生成的这个 Token ，只有生成的时候可以看到明文，后面就看不到明文了，所以你使用的时候最好一次操作成功。<br>2、Travis CI 中添加 Token 时，记得用密文，要不然在 <code>build log</code> 中是可以被看到的。<br></p>

<h2 id="方案二、"><a href="#方案二、" class="headerlink" title="方案二、"></a>方案二、</h2><p>你还可以使用 Travis CI 提供的加密工具来加密我们的这个 Token。加密原理机制如下：</p>
<p><img src="/images/travis-encrypt.png" alt="travis-ci-encrypt"></p>
<p>首先，安装 Ruby 的包 <code>travis</code> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Travis CI 命令行工具</span></span><br><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure></p>
<p>然后，就可以用 <code>travis encrypt</code> 命令加密信息。<br>在项目的根目录下，执行下面的命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt name=secretvalue</span><br></pre></td></tr></table></figure></p>
<p>上面命令中，<code>gh_token</code> 是要加密的变量名，<code>secretvalue</code> 是要加密的变量值。执行以后，屏幕上会输出如下信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">secure: &quot;... encrypted data ...&quot;</span><br></pre></td></tr></table></figure></p>
<p>现在，就可以把这一行加入 <code>.travis.yml</code> 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env:</span><br><span class="line">  global:</span><br><span class="line">    - GH_REF: github.com/Neveryu/xxxxx.git</span><br><span class="line">    - secure: <span class="string">"... entrypted data ..."</span></span><br></pre></td></tr></table></figure></p>
<p>然后，脚本里面就可以使用环境变量 <code>gh_token</code> 了，Travis 会在运行时自动对它解密。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;gh_token&#125; 对应就是 Personal access tokens ， gh_token 是环境变量名</span></span><br><span class="line"><span class="comment"># $&#123;GH_REF&#125; 对应的是你的 Github 仓库地址，GH_REF 是变量名</span></span><br><span class="line">git push -f <span class="string">"https://<span class="variable">$&#123;gh_token&#125;</span>@<span class="variable">$&#123;GH_REF&#125;</span>"</span> master:gh-pages</span><br></pre></td></tr></table></figure>
<p><code>travis encrypt</code> 命令的 <code>--add</code> 参数会把输出自动写入 <code>.travis.yml</code>，省掉了修改 <code>env</code> 字段的步骤。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt name=secretvalue --add</span><br></pre></td></tr></table></figure></p>
<p>详细信息请看<a href="https://docs.travis-ci.com/user/encryption-keys/" target="_blank" rel="noopener">官方文档</a></p>
<p id="div-border-top-red">可以参考我的 <a href="https://github.com/Neveryu/vue-cms" target="_blank" title="vue-cms">vue-cms</a> 这个项目中的 <code>.travis.yml</code> 文件</p>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="如何显示-Status-Image"><a href="#如何显示-Status-Image" class="headerlink" title="如何显示 Status Image"></a>如何显示 Status Image</h2><p><a href="https://travis-ci.org/Neveryu/web-bookmarks" target="_blank" rel="noopener"><img src="https://travis-ci.org/Neveryu/web-bookmarks.svg?branch=master" alt="Build Status"></a></p>
<p><img src="/images/travis-ci-4.png" alt="travis-ci-4"></p>
<h2 id="如何跳过自动构建"><a href="#如何跳过自动构建" class="headerlink" title="如何跳过自动构建"></a>如何跳过自动构建</h2><p>如果 commit 不想让 Travis 构建，那么就在 commit message 里加上 [ci skip] 就行了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"[ci skip] commit message"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h2><p>如果遇到脚本权限不够的提示或者问题，你可以给你的脚本加上权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x deploy.sh</span><br></pre></td></tr></table></figure></p>
<p>或者在 <code>.travis.yml</code> 里加：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="string">u+x</span> <span class="string">deploy.sh</span></span><br></pre></td></tr></table></figure></p>
<h1 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h1><h2 id="Travis-CI-加密文件"><a href="#Travis-CI-加密文件" class="headerlink" title="Travis CI 加密文件"></a>Travis CI 加密文件</h2><p>如果要加密的是文件（比如私钥），Travis 提供了加密文件功能。<br>安装命令行客户端以后，使用下面的命令登入 Travis CI 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis login</span><br></pre></td></tr></table></figure></p>
<p>然后，进入项目的根目录，使用 <code>travis encrypt-file</code> 命令加密那些想要加密的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ travis entrypt-file bacon.txt</span><br><span class="line"></span><br><span class="line">encrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Please add the following to your build script (before_install stage <span class="keyword">in</span> your .travis.yml, <span class="keyword">for</span> instance):</span><br><span class="line"></span><br><span class="line">    openssl aes-256-cbc -K <span class="variable">$encrypted_0a6446eb3ae3_key</span> -iv <span class="variable">$encrypted_0a6446eb3ae3_key</span> -<span class="keyword">in</span> bacon.txt.enc -out bacon.txt -d</span><br><span class="line"></span><br><span class="line">Pro Tip: You can add it automatically by running with --add.</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure></p>
<p>上面的代码对文件 <code>bacon.txt</code> 进行加密，加密后会生成 <code>bacon.txt.enc</code> ，该文件需要提交到代码库。此外，该命令还会生成一个环境变量 <code>$entrypted_0a6446eb3ae3_key</code>，保存密钥，储存在 Travis CI，文件解密时需要这个环境变量。你需要把解密所需的 <code>openssl</code> 命令，写在 <code>.travis.yml</code> 的 <code>before_install</code> 字段里面。这些都写在上面的命令行提示里面。</p>
<p><code>--add</code> 参数可以自动把环境变量写入 <code>.travis.yml</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt-file bacon.txt --add</span><br><span class="line">entrypting bacon.txt <span class="keyword">for</span> rkh/travis-encrypt-file-example</span><br><span class="line">storing result as bacon.txt.enc</span><br><span class="line">storing secure env variables <span class="keyword">for</span> decryption</span><br><span class="line"></span><br><span class="line">Make sure to add bacon.txt.enc to the git repository.</span><br><span class="line">Make sure not to add bacon.txt to the git repository.</span><br><span class="line">Commit all changes to your .travis.yml.</span><br></pre></td></tr></table></figure>
<p>详细信息请看<a href="https://docs.travis-ci.com/user/encrypting-files/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Yarn安装与使用详细介绍]]></title>
      <url>https://jiechengyang.github.io/2018/07/20/yarn/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 Node 生态系统中，依赖通常安装在项目的 <code>node_modules</code> 文件夹中。然而，这个文件的结构和实际依赖树可能有所区别，因为重复的依赖可以合并到一起。<code>npm</code> 客户端把依赖安装到 <code>node_modules</code> 目录的过程具有不确定性。这意味着当依赖的安装顺序不同时，<code>node_modules</code> 目录的结构可能会发生变化。这种差异可能会导致类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的情况，并且通常需要花费大量时间定为与解决。</p>
<blockquote>
<p>有时候就会遇到这种情况，完整可运行的项目上传到 git 上，别人 pull 下来以后，npm install 会报错。</p>
</blockquote>
<p><a href="https://github.com/yarnpkg/yarn" target="_blank" rel="noopener">Yarn</a> 一开始的主要目标是解决由于语义版本控制而导致的 npm 安装的不确定性问题。虽然可以用 <code>npm shrinkwrap</code> 来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员指导并启用这个选项。</p>
<a id="more"></a>
<blockquote>
<p>npm 5+ 以后的版本加入了 package-lock.json 可以用来锁版本，package-lock.json 的名字，一看就懂，更清楚，但是不向后兼容。</p>
</blockquote>
<blockquote>
<p>npm-shrinkwrap.json 向后兼容 npm 2-4。</p>
</blockquote>
<p><font color="red">举个例子：</font><br>npm 对包引入顺序也十分的敏感，比如在一个空项目里执行以下命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install globule@<span class="number">0.1</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-generator@<span class="number">6.19</span><span class="number">.0</span> -S</span><br><span class="line">npm install babel-helper-define-map@<span class="number">6.18</span><span class="number">.0</span> -S</span><br></pre></td></tr></table></figure></p>
<p>我们这里安装了 3 个包都依赖于 lodash，不过 globule 依赖 <a href="mailto:lodash@1.0.3" target="_blank" rel="noopener">lodash@1.0.3</a>，另外另个依赖 <a href="mailto:lodash@4.x" target="_blank" rel="noopener">lodash@4.x</a>。<br>现在目录依赖结构如下：<br><img src="https://img-blog.csdn.net/20180824142908356?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="npm-package"></p>
<p>这是假设我们在项目里使用 lodash，但是忘记重新安装 lodash<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(lodash.VERSION)  <span class="comment">// v1.0.3</span></span><br></pre></td></tr></table></figure></p>
<p>另一个同事获取项目代码，执行 <code>npm install</code>，这时的目录依赖结构里面，第一层依赖的 lodash 变成了 4.x 版本，这样就造成了依赖版本不一致的问题。而 yarn 则会保证无论怎样引入的顺序，目录依赖结构都是一致的，确保不会发生这样的BUG。</p>
<h1 id="什么是-Yarn"><a href="#什么是-Yarn" class="headerlink" title="什么是 Yarn"></a>什么是 Yarn</h1><p>Yarn 就是一个类似于 npm 的包管理工具，它是由 facebook 推出并开源。</p>
<p>与 npm 相比，yarn 有着众多的优势，主要的优势在于：速度快、离线模式、版本控制。</p>
<h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>npm 会等一个包完全安装完才跳到下一个包，但 yarn 会并行执行包，因此速度会快很多。</p>
<p>Yarn 会缓存它下载的每个包，所以无需重复下载。它还能并行化操作以最大化资源利用率，安装速度之快前所未有。</p>
<h2 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h2><p>之前安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来，这样做的本质还是会提高安装下载的速度，避免不必要的网络请求。</p>
<h2 id="可靠可确定性"><a href="#可靠可确定性" class="headerlink" title="可靠可确定性"></a>可靠可确定性</h2><p>保证各平台依赖的一致性</p>
<h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>力求网络资源最大利用化，让资源下载完美队列执行，避免大量的无用请求，下载失败会自动重新请求，避免整个安装过程失败</p>
<h2 id="扁平化模式"><a href="#扁平化模式" class="headerlink" title="扁平化模式"></a>扁平化模式</h2><p>对于不匹配的依赖版本的包创立一个独立的包，避免创建重复的。<br>对于多个包依赖同一个子包的情况，yarn 会尽量提取为同一个包，防止出现多处副本，浪费空间。</p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>npm 用下来比较强的一个痛点就是：当包的依赖层次比较深时，版本控制不够精确。会出现相同 package.json，但不同人的电脑上安装出不同版本的依赖包，出现类似<font color="red">“我的电脑上可以运行，别的电脑上不行”</font>的 bug 很难查找。你可以使用 <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="noopener">npm-shrinkwrap</a> 来实现版本固化，版本信息会写入 npm-shrinkwrap.json 文件中，但它毕竟不是 npm 的标准配置。</p>
<p>而 yarn 天生就能实现版本固化。会生成一个类似 npm-shrinkwrap.json 的 yarn.lock 文件，而文件内会描述包自身的版本号，还会锁定所有它依赖的包的版本号：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"@babel/code-frame@7.0.0-beta.47"</span>:</span><br><span class="line">  version <span class="string">"7.0.0-beta.47"</span></span><br><span class="line">  resolved <span class="string">"https://registry.yarnpkg.com/@babel/code-frame/-/code-frame-7.0.0-beta.47.tgz#d18c2f4c4ba8d093a2bcfab5616593bfe2441a27"</span></span><br><span class="line">  dependencies:</span><br><span class="line">    <span class="string">"@babel/highlight"</span> <span class="string">"7.0.0-beta.47"</span></span><br></pre></td></tr></table></figure></p>
<p>yarn.lock 存储着你的每个包的确切依赖版本，能确保从本地开发到生产环境，所有机器上都有精确相同的依赖版本。</p>
<h2 id="其他关于-Yarn-的介绍"><a href="#其他关于-Yarn-的介绍" class="headerlink" title="其他关于 Yarn 的介绍"></a>其他关于 Yarn 的介绍</h2><p>我们在使用 Yarn 时，依然要访问 npm 仓库，但 Yarn 能够更快速地安装软件包和管理依赖关系，并且可以在跨机器或者无网络的安全环境中保持代码的一致性。</p>
<h1 id="Yarn-安装"><a href="#Yarn-安装" class="headerlink" title="Yarn 安装"></a>Yarn 安装</h1><h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><p>在 Yarn 中文网可以找到 window 下的三种安装方法：</p>
<p><img src="https://img-blog.csdn.net/20180824120236673?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzZG5feXVkb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="yarn-install"></p>
<p>不过我觉得这三种方法都不好用，快速好用的安装方法应该还是使用 npm 来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure></p>
<p>关于为什么使用 <code>-g</code>，以及 <code>-g</code> 会带来哪来影响，这个可以看我的这篇文章：<a href="https://neveryu.github.io/2017/04/10/npm/" target="_blank" rel="noopener">npm详细介绍</a>，里面详细介绍了为什么要使用 <code>-g</code>，以及 <code>-g</code> 的作用。</p>
<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure>
<p>如果有报： <code>Please try running this command again as root/Administrator.</code>，可能就是权限不足，因此你需要切换到最高权限去执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">npm install yarn -g</span><br></pre></td></tr></table></figure></p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>使用另一种初始化脚本的方法，可能就会比较简单一些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- -L https://yarnpkg.com/install.sh | bash</span><br></pre></td></tr></table></figure></p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>如果你的电脑上面已经安装了 Homebrew 的话，你可以通过 Homebrew 包管理器安装 Yarn<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure></p>
<h1 id="Yarn-换源"><a href="#Yarn-换源" class="headerlink" title="Yarn 换源"></a>Yarn 换源</h1><p>Yarn 源仓库包下载不稳定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查看 yarn 配置</span><br><span class="line">yarn config get registry</span><br><span class="line">或者</span><br><span class="line">yarn config list</span><br><span class="line"></span><br><span class="line">&gt; registry: &apos;https://registry.yarnpkg.com&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装淘宝镜像</span><br><span class="line">yarn config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h1 id="Yarn-常用命令"><a href="#Yarn-常用命令" class="headerlink" title="Yarn 常用命令"></a>Yarn 常用命令</h1><ul>
<li><code>npm install</code> === <code>yarn</code>  —— install安装是默认行为</li>
<li><code>npm install taco --save</code> === <code>yarn add taco</code>  —— taco包立即被保存到 <code>package.json</code> 中。</li>
<li><code>npm uninstall taco --save</code> === <code>yarn remove taco</code></li>
<li><code>npm install taco --save-dev</code> === <code>yarn add taco --dev</code></li>
<li><code>npm update --save</code> === <code>yarn upgrade</code></li>
</ul>
<p>-</p>
<ul>
<li><code>npm install taco@latest --save</code> === <code>yarn add taco</code></li>
<li><code>npm install taco --global</code> === <code>yarn global add taco</code>  —— 一如既往，请谨慎使用 global 标记。</li>
</ul>
<blockquote>
<p>注意：使用yarn或yarn install安装全部依赖时是根据package.json里的”dependencies”字段来决定的</p>
</blockquote>
<p>-</p>
<ul>
<li><code>npm init</code> === <code>yarn init</code></li>
<li><code>npm init --yes/-y</code> === <code>yarn init --yes/-y</code></li>
<li><code>npm link</code> === <code>yarn link</code></li>
<li><code>npm outdated</code> === <code>yarn outdated</code></li>
<li><code>npm publish</code> === <code>yarn publish</code></li>
<li><code>npm run</code> === <code>yarn run</code></li>
<li><code>npm cache clean</code> === <code>yarn cache clean</code></li>
<li><code>npm login</code> === <code>yarn login</code></li>
<li><code>npm test</code> === <code>yarn test</code></li>
</ul>
<h2 id="Yarn-独有的命令"><a href="#Yarn-独有的命令" class="headerlink" title="Yarn 独有的命令"></a>Yarn 独有的命令</h2><ul>
<li><code>yarn licenses ls</code>  —— 允许你检查依赖的许可信息</li>
<li><code>yarn licenses generate</code>  —— 自动创建依赖免责声明 license</li>
<li><code>yarn why taco</code>  —— 检查为什么会安装 taco，详细列出依赖它的其他包</li>
<li><code>yarn why vuepress</code>  —— 检查为什么会安装 vuepress，详细列出依赖它的其他包</li>
</ul>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>Yarn 除了让安装过程变得更快与更可靠，还添加了一些额外的特性，从而进一步简化依赖管理的工作流。</p>
<ul>
<li>同时兼容 <code>npm</code> 与 <code>bower</code> 工作流，并支持两种软件仓库混合使用</li>
<li>可以限制已安装模块的协议，并提供方法输出协议信息</li>
<li>提供一套稳定的共有 JS API，用于记录构建工具的输出信息</li>
<li>可读、最小化、美观的 CLI 输出信息</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Yarn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue 服务端渲染 or 预渲染]]></title>
      <url>https://jiechengyang.github.io/2018/06/18/vue-prerender/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>关于 Vue 的 SPA 说的已经太多太多了，它为我们带来了极速的开发体验，极强的开发效率。可能唯一有些许不足的就是，当我们对 SEO 很在乎的时候，我们如何去处理 SEO 的需求。</p>
<p>关于 SEO ，Vue 也有现成的解决方案： <a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue 服务端渲染</a></p>
<a id="more"></a>
<h2 id="那么"><a href="#那么" class="headerlink" title="那么"></a>那么</h2><h3 id="什么是服务端渲染"><a href="#什么是服务端渲染" class="headerlink" title="什么是服务端渲染"></a>什么是服务端渲染</h3><p>服务端将完整的页面 html 输出到客户端显示，与 SPA （Single-Page-Application）使用 js 渲染页面不同。</p>
<h3 id="为什么使用服务端渲染"><a href="#为什么使用服务端渲染" class="headerlink" title="为什么使用服务端渲染"></a>为什么使用服务端渲染</h3><ul>
<li>更好的 SEO</li>
<li>更快的内容到达时间</li>
</ul>
<h3 id="服务端渲染-or-预渲染"><a href="#服务端渲染-or-预渲染" class="headerlink" title="服务端渲染 or 预渲染"></a>服务端渲染 or 预渲染</h3><p>就像官网所说的，如果你调研服务器端渲染(SSR)只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">预渲染</a>，一个典型的预渲染使用场景可能类似<a href="https://neveryu.github.io/vue-tour/" target="_blank" rel="noopener">这个网站</a>。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>服务端渲染</strong>和<strong>预渲染</strong>的使用场景还是有较明显的区别的。预渲染的使用场景更多是我们所说的静态页面的形式，比如说<a href="https://neveryu.github.io/vue-tour/" target="_blank" rel="noopener">这个网站</a>。服务端渲染适用于大型的、页面数据处理较多且较为复杂的、与服务端有数据交互的功能型网站，一个明显的使用场景就是电商网站。</p>
<h2 id="如何使用预渲染"><a href="#如何使用预渲染" class="headerlink" title="如何使用预渲染"></a>如何使用预渲染</h2><p><strong>预渲染</strong>的核心是使用 <a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>，如何使用它呢？我们还是以<a href="https://neveryu.github.io/vue-tour/" target="_blank" rel="noopener">这个网站</a>的<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="noopener">源代码</a>中的 webpack 配置为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> PrerenderSPAPlugin(&#123;</span><br><span class="line">  staticDir: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  routes: [ <span class="string">'/'</span>, <span class="string">'/home'</span>, <span class="string">'/infomation'</span>, <span class="string">'/ticket'</span>, <span class="string">'/scenery'</span>, <span class="string">'/about'</span> ],</span><br><span class="line">  renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    renderAfterDocumentEvent: <span class="string">'render-event'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></p>
<p>我们需要简单的配置一下，项目所有的路由，最终生成后有几个页面，都是以这个配置为依据，而不是你在 vue-router 中配置的路由。</p>
<p>最基础也最核心的配置项也就这几行代码，当然，如果你有更多的需求配置项，你可以去 github 上查看文档，文档中也有很详细的介绍。 </p>
<h2 id="如何搭建一个预渲染开发环境"><a href="#如何搭建一个预渲染开发环境" class="headerlink" title="如何搭建一个预渲染开发环境"></a>如何搭建一个预渲染开发环境</h2><p>如果你也想要使用<strong>预渲染</strong>来开发你的网站的话，最简单的方法就是克隆<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="noopener">这个项目</a>，然后简单删减以后进行二次开发，整个的开发流程和 Vue 是一模一样的。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>1、相较于 Vue 的模板中大而全的 webpack 配置项，<strong>预渲染</strong>中的 webpack 配置简单小巧，如果你有一些 webpack 的配置需求的话，你可能需要自己动手。</p>
<p>2、我的<a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="noopener">这个项目</a>使用的是 stylus 来作为 css 预编译语言，如果你想使用其他的 css 预编译语言的话，需要额外安装一些插件以及做一些简单配置。当然了，默认的 css 肯定是支持的。</p>
<p>3、在写这个项目的过程中，也有做一些简单的知识点记录。<a href="https://github.com/Neveryu/prerender-website/blob/master/project-note.md" target="_blank" rel="noopener">vue-prerender 笔记</a></p>
<p>4、最后项目打包发布到生产环境，使用 <code>npm run build</code> 一键操作即可。如果你想要部署到子目录下的话，那么，你可能需要做一些简单的修改，具体在 <a href="https://github.com/Neveryu/prerender-website/blob/master/project-note.md" target="_blank" rel="noopener">vue-prerender 笔记</a> 有提到。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><a href="https://neveryu.github.io/vue-tour/" target="_blank" rel="noopener">项目预览</a><br><a href="https://github.com/Neveryu/prerender-website" target="_blank" rel="noopener">项目github地址</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于 JavaScript 中 this 的详细总结]]></title>
      <url>https://jiechengyang.github.io/2018/06/01/js-this/</url>
      <content type="html"><![CDATA[<p id="div-border-top-blue">在 JavaScript 中，函数中的 this 指向，很多同学总是理不清楚【这必然会带来一些问题】。确实，JavaScript 中，函数的 this 指向比较复杂多变。它和你调用的方式有关系，和 <strong>严格模式</strong> 或者 <strong>非严格模式</strong> 有关系，和你是否使用了箭头函数有关系，和你在使用函数时是否传入了 this 有关系，和你是否主动修改了调用对象有关系。</p>

<ul>
<li>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值。<code>this</code> 不能再执行期间被赋值，并且在每次函数被调用时 <code>this</code> 的值也可能会不同。<code>ES5</code> 引入了 <code>bind</code> 方法来设置函数的 <code>this</code> 值，<a href="https://blog.csdn.net/csdn_yudong/article/details/78730844" target="_blank" rel="noopener">关于bind和call可以看我的文章</a>，而不用考虑函数如何被调用的，<code>ES2015</code> 引入了支持 <code>this</code> 词法解析的箭头函数（它在闭合的执行上下文内设置 <code>this</code> 的值）。</li>
</ul>
<ul>
<li>与其他语言相比，<strong>函数的 <code>this</code> 关键字</strong>在 <code>JavaScript</code> 中的表现略有不同，此外，在 严格模式 和 非严格模式之间也会有一些差别。</li>
</ul>
<a id="more"></a>
<h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）<code>this</code> 都指代全局对象。【在全局执行上下文中 <code>this</code> 都是全局对象 <code>window</code>】（浏览器环境）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// window</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.b);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数内部，<code>this</code> 的值取决于函数被调用的方式。【取决于被调用的方式】</p>
<h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line">f1() === <span class="built_in">window</span>;  <span class="comment">// 在浏览器中，全局对象是widnow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Node 中</span></span><br><span class="line">f1() === global;</span><br></pre></td></tr></table></figure>
<p>【在严格模式下，<code>this</code> 将保持他进入执行上下文时的值】</p>
<p>在严格模式下，<code>this</code> 将保持他进入执行上下文时的值，所以下面的 <code>this</code> 将会默认为 <code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以，在严格模式下，如果 <code>this</code> 没有被执行上下文（execution context）定义，那它将保持为 <code>undefined</code>。</p>
<p>因为 <code>f2()</code> 是被直接调用的，而不是作为对象的属性或方法调用的（如<code>window.f2()</code>）。有一些浏览器最初在支持严格模式时没有正确实现这个功能，于是它们错误的返回了 <code>window</code> 对象。</p>
<p>但是，如果用 <code>window</code> 来调用的话，<code>this</code> 就是 <code>window</code> 了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>; <span class="comment">// 这里是严格模式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.f2())  <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p>
<p>如果要想把 <code>this</code> 的值从一个上下文传到另一个，就要用 <code>call</code> 或者 <code>apply</code> 方法。</p>
<p>当一个函数在其主体中使用 <code>this</code> 关键字时，可以通过使用函数继承自 <code>Function.prototype</code> 的 <code>call</code> 或 <code>apply</code> 方法将 <code>this</code> 值绑定到调用中的特定对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 后续参数作为参数传递给函数调用</span></span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数也是作为‘this’使用的对象</span></span><br><span class="line"><span class="comment">// 第二个参数是一个数组，数组里的元素用作函数调用中的参数</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>call</code> 和 <code>apply</code> 函数的时候要注意，如果传递给 <code>this</code> 的值不是一个对象，<code>JavaScript</code> 会尝试使用内部 <code>ToObject</code> 操作将其转换为对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此，如果传递的值是一个原始值比如 <span class="number">7</span> 或 <span class="string">'foo'</span>，那么就会使用相关构造函数将它转换为对象，所以原始值 <span class="number">7</span> 会被转为对象，像 </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">7</span>) 这样，而字符串 <span class="string">'foo'</span> 转化成 <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'foo'</span>) 这样。</span><br></pre></td></tr></table></figure>
<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><p><code>ECMAScript 5</code> 引入了 <code>Function.prototype.bind</code>。调用 <code>f.bind(someObject)</code> 会 <strong>创建</strong>一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code> 将永久地被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的。</p>
<p>【<code>this</code> 将永久的被绑定到了 <code>bind</code> 的第一个参数，无论这个函数是如何被调用的】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;<span class="attr">a</span>:<span class="string">"azerty"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h = g.bind(&#123;<span class="attr">a</span>:<span class="string">'yoo'</span>&#125;); <span class="comment">// bind只生效一次！</span></span><br><span class="line"><span class="built_in">console</span>.log(h()); <span class="comment">// azerty</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">37</span>, <span class="attr">f</span>:f, <span class="attr">g</span>:g, <span class="attr">h</span>:h&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g(), o.h()); <span class="comment">// 37, azerty, azerty</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在箭头函数中，<code>this</code> 与封闭词法上下文的 <code>this</code> 保持一致。在全局代码中，它将被设置为全局对象。【封闭词法上下文 是什么意思，你知道吗？】<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着上面的代码</span></span><br><span class="line"><span class="comment">// 作为对象的一个方法调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用call来设定this</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.call(obj) === <span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试使用bind来设定this</span></span><br><span class="line">foo = foo.bind(obj);</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>【无论如何，<code>foo</code> 的 <code>this</code> 被设置为<strong>他被创建时的上下文</strong>（在上面的例子中，就是全局对象）】<br>这同样适用于在其他函数内创建的箭头函数：这些箭头函数的 <code>this</code> 被设置为封闭的词法上下文的。</p>
<h2 id="作为对象的方法"><a href="#作为对象的方法" class="headerlink" title="作为对象的方法"></a>作为对象的方法</h2><blockquote>
<p>当函数作为对象里的方法被调用时，它们的 <code>this</code> 是调用该函数的对象</p>
</blockquote>
<p><code>this</code> 的绑定只受最靠近的成员引用的影响。在下面的例子中，我们把一个方法 <code>g</code> 当做对象 <code>o.b</code> 的函数调用。在这次执行期间，函数中的 <code>this</code> 将指向 <code>o.b</code> 。事实证明，这与他是对象 <code>o</code> 的成员没有多大关系，最靠近的引用才是最重要的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.b = &#123; <span class="attr">g</span>: independent, <span class="attr">prop</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(o.b.g())</span><br></pre></td></tr></table></figure></p>
<h2 id="原型链中的-this"><a href="#原型链中的-this" class="headerlink" title="原型链中的 this"></a>原型链中的 <code>this</code></h2><p>对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 <code>this</code> 指向的是调用这个方法的对象，就像该方法在对象上一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，对象 <code>p</code> 没有属于它自己的 <code>f</code> 属性，它的 <code>f</code> 属性继承自它的原型。虽然在对 <code>f</code> 的查找过程中，最终是在 <code>o</code> 中找到 <code>f</code> 属性的，这并没有关系；查找过程首先从 <code>p.f</code> 的引用开始，所以函数中的 <code>this</code> 指向 <code>p</code>。也就是说，因为 <code>f</code> 是作为 <code>p</code> 的方法调用的，所以它的 <code>this</code> 指向了 <code>p</code> 。这是 <code>JavaScript</code> 的原型继承中的一个有趣的特性。</p>
<h2 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h2><p>当一个函数用作构造函数时（适用 <code>new</code> 关键字），它的 <code>this</code> 被绑定到正在构造的新对象。</p>
<p>虽然构造器返回的默认值是 <code>this</code> 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 <code>this</code> 对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造函数这样工作:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * function MyConstructor()&#123;</span></span><br><span class="line"><span class="comment"> *   // 函数实体写在这里</span></span><br><span class="line"><span class="comment"> *   // 根据需要在this上创建属性，然后赋值给它们，比如：</span></span><br><span class="line"><span class="comment"> *   this.fum = "nom";</span></span><br><span class="line"><span class="comment"> *   // 等等...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   // 如果函数具有返回对象的return语句，</span></span><br><span class="line"><span class="comment"> *   // 则该对象将是 new 表达式的结果。 </span></span><br><span class="line"><span class="comment"> *   // 否则，表达式的结果是当前绑定到 this 的对象。</span></span><br><span class="line"><span class="comment"> *   //（即通常看到的常见情况）。</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">37</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">38</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 38</span></span><br></pre></td></tr></table></figure>
<p>在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 <code>this</code> 绑定的默认对象被丢弃了。（这基本上使得语句 <code>this.a = 37;</code> 成了“僵尸”代码，实际上并不是真正的“僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。</p>
<h2 id="作为一个-DOM-事件处理函数"><a href="#作为一个-DOM-事件处理函数" class="headerlink" title="作为一个 DOM 事件处理函数"></a>作为一个 DOM 事件处理函数</h2><blockquote>
<p>当函数被用作事件处理函数时，它的 <code>this</code> 指向触发事件的元素（一些浏览器在使用非 <code>addEventListener</code> 的函数动态添加监听函数时不遵守这个约定）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用时，将关联的元素变成蓝色</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bluify</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.currentTarget); <span class="comment">// 总是 true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 currentTarget 和 target 是同一个对象时为 true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === e.target);        </span><br><span class="line">  <span class="keyword">this</span>.style.backgroundColor = <span class="string">'#A5D9F3'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文档中的所有元素的列表</span></span><br><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;elements.length ; i++)&#123;</span><br><span class="line">  elements[i].addEventListener(<span class="string">'click'</span>, bluify, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="作为一个内联事件处理函数"><a href="#作为一个内联事件处理函数" class="headerlink" title="作为一个内联事件处理函数"></a>作为一个内联事件处理函数</h2><blockquote>
<p>当代码被内联 <code>on-event</code> 处理函数 调用时，它的 <code>this</code> 指向监听器所在的 <code>DOM</code> 元素</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert(this.tagName.toLowerCase());"</span>&gt;</span></span><br><span class="line">  Show this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的 <code>alert</code> 会显示 <code>button</code> 。注意只有外层代码中的 <code>this</code> 是这样设置的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert((function()&#123;return this&#125;)());"</span>&gt;</span></span><br><span class="line">  Show inner this</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，没有设置内部函数的 <code>this</code>，所以它指向 <code>global/window</code> 对象（即非严格模式下调用的函数未设置 <code>this</code> 时指向的默认对象）。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Service worker 实现加速/离线访问博客]]></title>
      <url>https://jiechengyang.github.io/2017/06/08/service-worker/</url>
      <content type="html"><![CDATA[<p>有一个困扰 web 用户多年的难题——丢失网络连接。即使是世界上最好的 web app，如果下载不了它，也是非常糟糕的体验。如今虽然已经有很多种技术去尝试着解决这一问题。而随着<strong>离线页面</strong>的出现，一些问题已经得到了解决。有一个叫做 APP Cache 的 API 可以提供离线体验，但它的问题比较多。最重要的问题是，仍然没有一个好的统筹机制对资源缓存和自定义的网络请求进行控制。</p>
<h1 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h1><p>于是 HTML5 提出了 Service Worker，Service worker 提供了很多新的能力，使得 web app 拥有与 nativeapp 相同的离线体验、消息推送体验。</p>
<a id="more"></a>
<p>Service worker 是一段脚本，它有能力往我们的浏览器中写入缓存，过滤网络请求，将缓存内容作为网络响应结果输出。<br><strong>带来的效果是显而易见的：</strong></p>
<p id="div-border-top-green">1、当我们缓存了某些资源的时候，当我们再次请求该资源的时候，我们便可以使用缓存的内容，这样的话，就可以减少网络请求了，网站的打开速度明显提升。<br>2、如果我们将网站所需的资源缓存下来了以后，这个时候即使计算机没有网络，依然可以打开这个网站，即离线访问。<br></p>

<h1 id="Service-worker-使用场景"><a href="#Service-worker-使用场景" class="headerlink" title="Service worker 使用场景"></a>Service worker 使用场景</h1><p>现在很流行基于 GitHub page 和 markdown 的静态 blog ，非常适合技术的思维和习惯，针对不同的语言都有一些优秀的静态 blog 系统出现，如 Jekyll/Ruby，Pelican/Python，Hexo/NodeJs ，由于静态内容的特性非常适合做缓存来加速页面的访问，就利用 Service worker 来实现加速，结果是除了 PageSpeed，CDN 这些常见的服务器和网络加速之外，通过客户端实现了更好的访问体验。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>你现在可以断开你的网络，或者用浏览器中模拟无网络的情景，继续访问本站。<br><i style="color:red;">如何在浏览器中模拟无网络环境？(在 Network 中选择 offline)</i><br><img src="/images/service-worker-1.png" alt></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="注册-Service-worker"><a href="#注册-Service-worker" class="headerlink" title="注册 Service worker"></a>注册 Service worker</h2><p>要安装 Service worker，你需要在你的页面上注册它。下面的代码会告诉浏览器你的 Service worker 脚本放在哪里<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    <span class="comment">// 注册Service Worker scope表示作用的页面的path</span></span><br><span class="line">    <span class="comment">// register函数返回Promise</span></span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>,&#123;<span class="attr">scope</span>: <span class="string">'/'</span>&#125;) </span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(registration);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Service Worker is not supported in this browser.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码会先检测 Service worker 在浏览器中是否可用，可用的话一个 Service worker（/service-worker.js）将被注册，如果这个 Service worker 已经注册过了，浏览器这会忽略以上代码。<br><code>{scope: &#39;/&#39;}</code> 表示 Service worker 作用的范围。<br>需要说明的是 service-worker.js 文件被放在这个域的根目录下，这意味着 service worker 是跟网站同源的。换句话说，这个 service worker 将会获取到这个域下的所有 fetch 事件。<br>如果 service worker 文件注册到 /example/service-worker.js ，那么 service worker 只能收到 /example/ 路径下的 fetch 事件（比如： /example/page1/, /example/page2/）。<br>如果 service worker 文件注册到根目录下 /service-worker.js ，同时 <code>{scope: &#39;/example&#39;}</code> ，那么 service worker 也只能收到 /example/ 路径下的 fetch 事件。</p>
<p>service-worker.js 文件，我建议是放在网站的跟目录下，scope 不作修改，这样 service worker 拥有最大的使用范围。</p>
<h2 id="安装-Service-worker"><a href="#安装-Service-worker" class="headerlink" title="安装 Service worker"></a>安装 Service worker</h2><p><img src="/images/service-worker-2.png" alt></p>
<p><a href="https://neveryu.github.io/service-worker.js" target="_blank" rel="noopener">我的 service-worker.js</a><br>关于这个 service-worker.js 怎么写，具体可以查看 API ，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN Service Worker API</a>。</p>
<p id="div-border-left-red">注意：将 service-worker.js 放到域的根目录下哦，这样 Service worker 才能拥有最大的使用范围。</p>

<p>现在你可以到 chrome://inspect/#service-workers 这里，检查 service worker 是否对你的网站启用了。<br>或者在 chrome://serviceworker-internals/ 中管理你的 Service worker 。<br>或者在浏览器的开发者工具中也可以详细的查看 service worker 的缓存。<br><img src="/images/service-worker-3.png" alt></p>
<h1 id="Service-worker-核心-API"><a href="#Service-worker-核心-API" class="headerlink" title="Service worker 核心 API"></a>Service worker 核心 API</h1><p><img src="/images/service-worker-4.png" alt></p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p><img src="/images/service-worker-5.png" alt><br>install 是安装一个 service worker 缓存，使用方法可以是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the callback for the install step</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform install steps</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在 install 的 callback 中，我们需要执行一下步骤：<br>1、开启一个缓存<br>2、缓存我们的文件<br>3、确定所有的资源是否要被缓存</p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch 用来监听用户的网络请求，并给出回应。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Cache hit - return response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="activate"><a href="#activate" class="headerlink" title="activate"></a>activate</h2><p>你的 Service worker 总会有要更新的时候。在那时，你需要按照一下步骤来更新：<br>1、更新你 service worker 的 JavaScript 文件。<br>2、更新后的 service worker 启动并触发 install 事件。<br>3、此时，当前页面生效的依然是老版本的 service worker ，新的 service worker 会进入“waitting”状态。<br>4、当页面关闭后，来的 service worker 会被干掉，新的 service worker 接管页面。<br>5、一旦新的 service worker 生效后会触发 active 事件。</p>
<p>一个典型的 activete 事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; </span><br><span class="line"><span class="comment">// 监听worker的activate事件</span></span><br><span class="line">  event.waitUntil( <span class="comment">// 延迟activate事件直到</span></span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keys</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keys.map(<span class="function"><span class="keyword">function</span>(<span class="params">key, i</span>)</span>&#123; <span class="comment">// 清除旧版本缓存</span></span><br><span class="line">        <span class="keyword">if</span>(key !== CACHE_VERSION)&#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(keys[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h1><p>在网站 A 中，隐藏一个 iframe ，在这个 iframe 中注册一个 service worker ，这个 service worker 会缓存网站 B 所需的资源。<br>从未访问过网站 B，但网站已经在你的设备上预加载过了，一切仅仅因为你访问过网站 A。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://B.com/iframe.html"</span> <span class="attr">style</span>=<span class="string">"width: 0; height: 0; border: 0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;HTML5 For Web Designers&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">if ('serviceWorker' in navigator) &#123;</span></span><br><span class="line"><span class="regexp">  navigator.serviceWorker.register('/</span>serviceworker.js<span class="string">');</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Service-worker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm 的一个小细节]]></title>
      <url>https://jiechengyang.github.io/2017/05/20/npm-two/</url>
      <content type="html"><![CDATA[<p>在使用 electron 构建桌面应用的时候，在 package.json 里面的 scripts 字段是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;electron .&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>我们可以执行 npm start ，那么它就会执行 <code>electron .</code> 这个命令。<br>那么如果我们直接执行 <code>electron .</code><br>由于我们没有将 electron 加入到全局，所以不行。<br>那么为什么 npm start 可以执行呢？</p>
<a id="more"></a>
<p>这就涉及到 npm run 命令的一个小细节了。<br>npm run xxx 可以执行 package.json 里面 scripts 里面对应的命令，并且是 shell 脚本。但是在执行的时候有一个小处理：</p>
<p><strong>npm run 新建的这个 shell ，会将当前目录的 node_modules/.bin 子目录加入 PATH 变量，执行结束后，再将 PATH 变量恢复原样。</strong></p>
<p>这就解释了，没有安装全局的 electron ，直接运行 <code>electron .</code> 是不行的，但是使用 <code>npm start</code> 来运行 <code>electron .</code> 可以。</p>
<p><strong>下面介绍一个使用 npm 的实践：</strong><br>很多朋友使用 hexo 来构建博客；hexo 是基于 Node.js 产物，用它发表博文，很是方便；你只需 hexo clean, hexo g, hexo d三个命令即可；而且每一个命令必须等待前一个命令运行完成。文章数据一多，一套命令打下来，也得 20s+；如果略懂 npm，在 package.js 中加入点命名，例如像这样；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"sudo hexo clean &amp;&amp; sudo hexo g &amp;&amp; sudo gulp &amp;&amp; sudo hexo d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么 只需运行 npm start 就好，可将时间消耗缩短至 2s节省时间虽说不多，却也是数量级的提升，而且代价只是那么小，并一劳永逸。所以有必要对此。</p>
<p>关于 npm 的详细学习，可以查看：<a href="https://neveryu.github.io/2017/04/10/npm/" target="_blank" rel="noopener">npm 全面介绍</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp 详解与使用]]></title>
      <url>https://jiechengyang.github.io/2017/05/01/gulp/</url>
      <content type="html"><![CDATA[<h1 id="什么是-gulp"><a href="#什么是-gulp" class="headerlink" title="什么是 gulp"></a>什么是 gulp</h1><p><a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 是一个前端构建工具，它能通过自动执行常见任务，比如编译预处理 CSS ，压缩 JavaScript 和刷新浏览器，来改进网站开发的过程，从而使开发更加快速高效。</p>
<h1 id="为什么要用-gulp"><a href="#为什么要用-gulp" class="headerlink" title="为什么要用 gulp"></a>为什么要用 gulp</h1><p>与 grunt 相比，gulp 无需写一大堆繁杂的配置参数，<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">API</a>（<a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">中文 API</a>） 也非常简单，学习起来很容易，而且 gulp 使用的是 nodejs 中 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 来读取和操作数据，其速度更快。<br>gulp 有庞大的生态圈，且每天都在发展。依靠成千上万可供选择的插件，你可以利用 gulp 自动完成几乎任何事。</p>
<h1 id="如何使用-gulp"><a href="#如何使用-gulp" class="headerlink" title="如何使用 gulp"></a>如何使用 gulp</h1><h2 id="Installing-Gulp"><a href="#Installing-Gulp" class="headerlink" title="Installing Gulp"></a>Installing Gulp</h2><p>新版的 gulp 命令行工具已经改名为 gulp-cli 。<br>如果你之前安装了全局的 gulp 。在使用新的 gulp-cli 之前，执行命令<br> <code>npm rm --global gulp</code> ，将之前的全局 gulp 卸掉。</p>
<a id="more"></a>
<h3 id="Install-the-gulp-command"><a href="#Install-the-gulp-command" class="headerlink" title="Install the gulp command"></a>Install the gulp command</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global gulp-cli</span><br></pre></td></tr></table></figure>
<h3 id="Install-gulp-in-your-devDependencies"><a href="#Install-gulp-in-your-devDependencies" class="headerlink" title="Install gulp in your devDependencies"></a>Install gulp in your devDependencies</h3><p>Run this command in your project directory<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure></p>
<h2 id="Create-a-gulpfile"><a href="#Create-a-gulpfile" class="headerlink" title="Create a gulpfile"></a>Create a gulpfile</h2><p>Create a file called gulpfile.js in your project root with these contents:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// place code for your default tash here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Test-it-out"><a href="#Test-it-out" class="headerlink" title="Test it out"></a>Test it out</h2><p>Run the gulp command in your projct directory:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure></p>
<h1 id="gulp-API"><a href="#gulp-API" class="headerlink" title="gulp API"></a>gulp API</h1><p>gulp 的核心 API 有四个：gulp.task() 、 gulp.src() 、 gulp.dest() 、 gulp.watch() 。<br><a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">gulp API</a><br><a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="noopener">gulp API 中文</a></p>
<p>下面详细介绍一下：</p>
<h2 id="gulp-src"><a href="#gulp-src" class="headerlink" title="gulp.src()"></a>gulp.src()</h2><p>gulp.src() 可以读取你需要操作的文件，相比于 Grunt 主要以文件为媒介来运行它的工作流，gulp 使用的是 Nodejs 中的 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">stream</a> 流，首先获取到需要的 stream ，然后可以通过 stream 的 pipe() 方法把流导入到你想要的地方，比如 gulp 的插件中，经过插件处理后的流又可以继续导入到其他插件中，当然也可以把流写入到文件中。所以 gulp 是以 stream 为媒介的，它不需要频繁的生成临时文件，这也是 gulp 的速度比 Grunt 快的一个原因。再回到正题上来，gulp.src() 方法正是用来获取流的，但要注意这个流里的内容不是原始的文件流，而是一个虚拟文件对象流（Vinyl files），这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这个我们暂时不用去深入理解，你只需简单的理解可以用这个方法来读取你需要操作的文件就行了。其语法为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(globs [, options])</span><br></pre></td></tr></table></figure></p>
<p>gulp 用到的 glob 的匹配规则以及一些文件匹配技巧。<br>gulp 内部使用了 node-glob 模块来实现其文件匹配功能。我们可以使用下面这些特殊的字符来匹配我们想要的文件：</p>
<ul>
<li><code>*</code> 匹配文件路径中的 0 个或多个字符，但不会匹配路径分配符，除非路径分隔符出现在末尾</li>
<li>** 匹配路径中的 0 个或多个目录及其子目录，需要单独出现，即它左右不能有其他东西了。如果出现在末尾，也能匹配文件。</li>
<li>? 匹配文件路径中的一个字符（不会匹配路径分隔符）</li>
<li>[…] 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为 ^ 或 ! 时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法。</li>
<li>!(pattern|pattern|pattern) 匹配任何与括号中给定的任一模式都不匹配的</li>
<li>?(pattern|pattern|pattern) 匹配括号中给定的任一模式 0 次或 1 次，类似于 js 正则中的(pattern|pattern|pattern)?</li>
<li>+(pattern|pattern|pattern) 匹配括号中给定的任一模式至少 1 次，类似于正则中的(pattern|pattern|pattern)+</li>
<li><code>*(pattern|pattern|pattern)</code> 匹配括号中的给定的任一模式 0 次或多次，类似于 js 正则中的 <code>(pattern|pattern|pattern)*</code></li>
<li>@(pattern|pattern|pattern) 匹配括号中给定的任一模式 1 次，类似于 js 正则中的(pattern|pattern|pattern)</li>
</ul>
<p>下面以一系列例子来加深理解</p>
<ul>
<li><code>*</code> 能匹配 a.js 、 x.y 、 abc 、 abc/ ，但不能匹配 a/b.js</li>
<li><code>*.*</code> 能匹配 a.js 、 style.css 、 a.b 、 x.y</li>
<li><code>*/*/*.js</code> 能匹配 a/b/c.js 、 x/y/z.js ，不能匹配 a/b.js 、a/b/c/d.js</li>
<li>** 能匹配 abc 、 a/b.js 、 a/b/c.js 、 x/y/z 、x/y/z/a.b ，能用来匹配所有的目录和文件</li>
<li>*<em>/</em>.js 能匹配 foo.js 、 a/foo.js 、 a/b/foo.js 、 a/b/c/foo.js</li>
<li>a/**/z 能匹配 a/z 、 a/b/z 、 a/b/c/z 、 a/d/g/h/r/z</li>
<li><code>a/**b/z</code> 能匹配 a/b/z 、 a/fb/z ，但不能匹配 a/x/gb/z ，因为只有单 ** 单独出现才能匹配多级目录</li>
<li>?.js 能匹配 a.js 、 b.js 、 c.js</li>
<li>a?? 能匹配 a.b 、 abc ，但不能匹配 ab/ ，因为它不会匹配路径分隔符</li>
<li>[xyz].js 只能匹配 x.js 、 y.js 、 z.js ，不会匹配 xy.js 、 xyz.js 等，整个中括号只代表一个字符</li>
<li>[^xyz].js 能匹配 a.js 、 b.js 、 c.js 等，不能匹配 x.js 、 y.js 、 z.js</li>
</ul>
<p>当有多种匹配模式时可以使用数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组的方式来匹配多种文件</span></span><br><span class="line">gulp.src([<span class="string">'js/*.js'</span>,<span class="string">'css/*.css'</span>,<span class="string">'*.html'</span>])</span><br></pre></td></tr></table></figure></p>
<p>使用数组的方式还有一个好处就是可以很方便的使用排除模式，在数组中的单个匹配模式前加上 ! 即是排除模式，它会在匹配的结果中排除这个匹配，要注意一点的是不能在数组中的第一个元素中使用排除模式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([*.js,<span class="string">'!b*.js'</span>])  <span class="comment">//匹配所有 js 文件，但排除掉以 b 开头的 js 文件</span></span><br><span class="line">gulp.src([<span class="string">'!b*.js'</span>,*.js])  <span class="comment">//不会排除任何文件，因为排除模式不能出现在数组的第一个元素中</span></span><br></pre></td></tr></table></figure></p>
<p>此外，还可以使用展开模式。展开模式以花括号作为定界符，根据它里面的内容，会展开为多个模式，最后匹配的结果为所有展开的模式想加起来得到的结果。展开的例子如下：</p>
<ul>
<li>a{b,c}d 会展开为 abd 、 acd</li>
<li>a{b,}c 会展开为 abc 、 ac</li>
<li>a{0..3}d 会展开为 a0d 、 a1d 、 a2d 、 a3d </li>
<li>a{b,c{d,e}f}g 会展开为 abg 、 acdfg 、 acefg</li>
<li>a{b,c}d{e,f}g 会展开为 abdeg 、 acdeg 、 abdfg 、 abdeg</li>
</ul>
<h2 id="gulp-dest"><a href="#gulp-dest" class="headerlink" title="gulp.dest()"></a>gulp.dest()</h2><p>gulp.dest() 方法是用来写文件的，其语法为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure></p>
<p><strong>path</strong> 为写入文件的路径<br>我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当作是目录名，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line">gulp.src(<span class="string">"script/jquery.js"</span>).pipe(gulp.dest(<span class="string">"dist/foo.js"</span>));</span><br><span class="line"><span class="comment">// 最终生成的文件路径为 dist/foo.js/jquery.js ，而不是 dist/foo.js</span></span><br></pre></td></tr></table></figure></p>
<p>要想改变文件名，可以使用插件 gulp-rename<br>下面说说生成的文件路径与我们给 gulp.dest() 方法传入的路径参数之间的关系。<br>gulp.dest(path) 生成的文件路径是我们传入的 path 参数后面再加上 gulp.src() 中有通配符开始出现的那部分路径。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/*.js</span></span><br><span class="line">gulp.src(<span class="string">"script/**/*.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//最后生成的文件路径为 dist/**/*.js</span></span><br><span class="line"><span class="comment">//如果 **/*.js 匹配到的文件为 jquery/jquery.js ，则生成的文件路径为 dist/jquery/jquery.js</span></span><br></pre></td></tr></table></figure></p>
<p>再举更多一点的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/avalon/avalon.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//没有通配符出现的情况，最后生成的文件路径为 dist/avalon.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/**/underscore.js"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符开始出现的那部分路径为 **/underscore.js</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/util/underscore.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/util/underscore.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/*"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//有通配符出现的那部分路径为*</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/zepto.js</span></span><br><span class="line"><span class="comment">//则最后生成的文件路径为dist/zepto.js</span></span><br></pre></td></tr></table></figure></p>
<p>通过指定 gulp.src() 方法配置参数中的 base 属性，我们可以灵活的来改变 gulp.dest() 生成的文件路径。<br>当我们没有在 gulp.src() 方法配置参数中的 base 属性，base 的默认值为通配符开始出现之前那部分路径，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>) <span class="comment">//此时base的值为 app/src</span></span><br></pre></td></tr></table></figure></p>
<p>上面我们说的 gulp.dest() 所生成的文件路径的规则，其实也可以理解成，用我们给 gulp.dest() 传入的路径替换掉 gulp.src() 中的 base 路径，最终得到生成文件的路径。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"app/src/**/*.css"</span>).pipe(gulp.dest(<span class="string">"dist"</span>));</span><br><span class="line"><span class="comment">//此时base的值为app/src，也就是说它的base路径为app/src</span></span><br><span class="line"><span class="comment">//设该模式匹配到了文件app/src/css/normal.css</span></span><br><span class="line"><span class="comment">//用dist替换掉base路径，最终得到dist/css/normal.css</span></span><br></pre></td></tr></table></figure></p>
<p>所以改变 base 路径后，gulp.dest() 生成的文件路径也会改变<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//没有配置base参数，此时默认的base路径为script/lib</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//生成的文件路径为build/jquery.js</span></span><br><span class="line"></span><br><span class="line">gulp.src(<span class="string">"script/lib/*.js"</span>, &#123;<span class="attr">base</span>: <span class="string">"script"</span>&#125;).pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line"><span class="comment">//配置了base参数，此时base路径为script</span></span><br><span class="line"><span class="comment">//假设匹配到的文件为script/lib/jquery.js</span></span><br><span class="line"><span class="comment">//此时生成的文件路径为build/lib/jquery.js</span></span><br></pre></td></tr></table></figure></p>
<p>用 gulp.dest() 把文件流写入文件后，文件流仍然可以继续使用。</p>
<h2 id="gulp-task"><a href="#gulp-task" class="headerlink" title="gulp.task()"></a>gulp.task()</h2><p>gulp.task 方法用来定义任务，内部使用的是 Orchestrator ，其语法为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure></p>
<p><strong>name</strong> 为任务名，如果你需要在命令行中运行你的某些任务，那么，请不要在名字中使用空格。<br><strong>deps</strong> 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。<br><strong>fn</strong> 为任务函数，我们把任务要执行的代码都要写在里面。该参数也是可选的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"mytask"</span>, [<span class="string">"array"</span>, <span class="string">"of"</span>, <span class="string">"task"</span>, <span class="string">"names"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//定义一个有依赖的任务</span></span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>关于 gulp.task() ，我们需要知道执行多个任务时怎么来控制任务执行的顺序。<br>gulp 中执行多个任务，可以通过任务依赖来实现。例如我想要执行 one ，two ，three 这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要执行default任务，就相当于把one,two,three这三个任务执行了</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>]);</span><br></pre></td></tr></table></figure></p>
<p>如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。<br>但是如果某个任务所依赖的任务是异步的，就要注意了，gulp 并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'one'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">  &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//two任务虽然依赖于one任务，但并不会等到one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/gulp-1.png" alt><br>上面的例子中我们执行 two 任务时，会先执行 one 任务，但不会去等待 one 任务中的异步操作完成后再执行 two 任务，而是紧接着执行 two 任务。因为 one 任务耗时 3 秒，所以 two 任务会在 one 任务中的异步操作完成之前就执行了。</p>
<p>那如果我们想等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？<br>有三种方法可以实现：</p>
<p>第一：在异步操作完成后执行一个回调函数来通知 gulp 这个异步任务已经完成，这个回调函数就是任务函数的第一个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//cb为任务函数提供的回调，用来通知任务已经完成</span></span><br><span class="line">  <span class="comment">//one是一个异步执行的任务</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"one is done"</span>);</span><br><span class="line">    cb(); <span class="comment">//执行回调，表示这个异步任务已经完成</span></span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这时two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>第二：定义任务时返回一个流对象。适用于任务就是操作 gulp.src 获取到的流的情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stream = gulp.src(<span class="string">"client/**/*.js"</span>)</span><br><span class="line">      .pipe(dosomething()) <span class="comment">//dosomething()中有某些异步操作</span></span><br><span class="line">      .pipe(gulp.dest(<span class="string">"build"</span>));</span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是two任务会在one任务中的异步操作完成后再执行</span></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>第三：返回一个 promise 对象，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>); <span class="comment">//一个著名的异步处理的库 https://github.com/kriskowal/q</span></span><br><span class="line">gulp.task(<span class="string">"one"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  <span class="comment">//做一些异步操作</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    deferred.resolve();</span><br><span class="line">  &#125;,<span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">"two"</span>, [<span class="string">"one"</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"two is done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>关于 gulp.task() ，主要的就是要清除当依赖异步任务时要如何处理。</p>
<h2 id="gulp-watch"><a href="#gulp-watch" class="headerlink" title="gulp.watch()"></a>gulp.watch()</h2><p>gulp.watch() 用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(glob[, opts], tasks);</span><br></pre></td></tr></table></figure></p>
<p><strong>glob</strong> 为要监视的文件匹配模式，规则和用法与 gulp.src() 方法中的 glob 相同。<br><strong>opts</strong> 为一个可选的配置对象，通常不需要用到。<br><strong>tasks</strong> 为文件变化后要执行的任务，为一个数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">"uglify"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(<span class="string">"reload"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, [<span class="string">"uglify"</span>,<span class="string">"reload"</span>]);</span><br></pre></td></tr></table></figure></p>
<p>gulp.watch(glob [,opts, cb])<br><strong>glob</strong> 和 <strong>opts</strong> 参数与第一种用法相同<br><strong>cb</strong> 参数为一个函数。每当监视的文件发生变化时，就会调用这个函数，并且会给它传入一个对象，该对象包含了文件变化的一些信息，type 属性为变化的类型，可以是 added 、changed 、deleted ，path 属性为发生变化的文件的路径<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(<span class="string">"js/**/*.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type); <span class="comment">//变化类型added为新增，deleted为删除，changed为改变</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.path); <span class="comment">//变化的文件的路径</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="gulp-的插件"><a href="#gulp-的插件" class="headerlink" title="gulp 的插件"></a>gulp 的插件</h1><p>gulp 本身虽然不能完成很多任务，但它有大量插件可用，我们可以在 <a href="http://gulpjs.com/plugins/" target="_blank" rel="noopener">插件页面</a> 或者在 npm 搜索 gulpplugin 。<br>列一些很棒的 plugin ：</p>
<ul>
<li><a href="https://www.npmjs.com/package/gulp-jshint/" target="_blank" rel="noopener">JSHint</a> ： js代码检查分析工具</li>
<li><a href="https://www.npmjs.com/package/gulp-coffee/" target="_blank" rel="noopener">gulp-coffee</a> ： 编译CoffeeScript</li>
<li><a href="https://www.npmjs.com/package/gulp-mocha" target="_blank" rel="noopener">gulp-mocha</a> ： 执行Mocha测试</li>
<li><a href="https://www.npmjs.com/package/gulp-bump" target="_blank" rel="noopener">gulp-bump</a> ： 更新版本号</li>
<li><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="noopener">gulp-sass</a> ： sass 编译</li>
<li><a href="http://www.browsersync.cn/docs/gulp/" target="_blank" rel="noopener">browser-sync</a> ： 浏览器自动刷新</li>
<li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a> ： 代码压缩</li>
<li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="noopener">gulp-concat</a> ： 合并</li>
<li><a href="https://www.npmjs.com/package/gulp-eslint" target="_blank" rel="noopener">gulp-eslint</a> ： 支持 ES6 JSX</li>
</ul>
<h1 id="gulp-命令行参数"><a href="#gulp-命令行参数" class="headerlink" title="gulp 命令行参数"></a>gulp 命令行参数</h1><ul>
<li><code>-v</code> 或 <code>--version</code> 会显示全局和项目本地所安装的 gulp 版本号</li>
<li><code>--require &lt;module path&gt;</code> 将会在执行之前 require 一个模块。这对于一些语言编译器或者需要其他应用的情况来说很有用。你可以使用多个 <code>--require</code></li>
<li><code>--gulpfile &lt;gulpfile path&gt;</code> 手动指定一个 gulpfile 的路径，这在你有很多个 gulpfile 的时候很有用。这也会将 CWD 设置到该 gulpfile 所在目录</li>
<li><code>--cwd &lt;dir path&gt;</code> 手动指定 CWD 。定义 gulpfile 查找的位置，此外，所有的相应的依赖（require）会从这里开始计算相对路径</li>
<li><code>-T</code> 或 <code>--tasks</code> 会显示所指定 gulpfile 的 task 依赖树</li>
<li><code>--tasks-simple</code> 会以纯文本的方式显示所载入的 gulpfile 中的 task 列表</li>
<li><code>--color</code> 强制 gulp 和 gulp 插件显示颜色，即便没有颜色支持</li>
<li><code>--no-color</code> 强制不显示颜色，即便检测到有颜色支持</li>
<li><code>--silent</code> 禁止所有的 gulp 日志</li>
</ul>
<p>命令行会在 process.env.INIT_CW 中记录它是从哪里被运行的。</p>
<h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>1、gulp 写进项目 package.json 文件的依赖有什么作用<br>方便别人查看你项目中有些什么依赖，而且在项目目录下执行 npm install 命令会安装项目 package.json 中的所有依赖模块，这样就能简化项目的安装程序了，不用一个一个模块去安装啊。</p>
<p>2、gulp 中着重了解 gulp.task() 如何处理依赖任务是耗时操作或者异步操作的情况。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[npm 全面介绍]]></title>
      <url>https://jiechengyang.github.io/2017/04/10/npm/</url>
      <content type="html"><![CDATA[<!-- <img src="http://i1.piimg.com/588926/30e7b49044d5cfc4.png" alt="summary-img-src-npm"> -->
<a id="more"></a>
<h1 id="什么是-NPM"><a href="#什么是-NPM" class="headerlink" title="什么是 NPM"></a>什么是 NPM</h1><p>npm 之于 Node.js ，就像 pip 之于 Python， gem 之于 Ruby， pear 之于 PHP 。</p>
<p>npm 是 Node.js 官方提供的包管理工具，他已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>
<h1 id="为什么要使用-NPM"><a href="#为什么要使用-NPM" class="headerlink" title="为什么要使用 NPM"></a>为什么要使用 NPM</h1><p>npm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的场景有以下几种：</p>
<ul>
<li>允许用户从 npm 服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。</li>
</ul>
<p>npm 的背后，是基于 couchdb 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p>
<h1 id="如何使用-NPM"><a href="#如何使用-NPM" class="headerlink" title="如何使用 NPM"></a>如何使用 NPM</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure></p>
<p>如果是 Window 系统使用以下命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure></p>
<p>也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。</p>
<p>然后，运行下面的命令，查看各种信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 npm 命令列表</span></span><br><span class="line">$ npm <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看各个命令的简单用法</span></span><br><span class="line">$ npm -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的版本</span></span><br><span class="line">$ npm -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 npm 的配置</span></span><br><span class="line">$ npm config list -l</span><br></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p>npm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br></pre></td></tr></table></figure></p>
<h3 id="npm-set"><a href="#npm-set" class="headerlink" title="npm set"></a>npm set</h3><p>npm set 用来设置环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">set</span> init-author-name <span class="string">'Your name'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-email <span class="string">'Your email'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-author-url <span class="string">'http://yourdomain.com'</span></span><br><span class="line">$ npm <span class="built_in">set</span> init-license <span class="string">'MIT'</span></span><br></pre></td></tr></table></figure></p>
<p>上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json 的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。</p>
<h3 id="npm-info"><a href="#npm-info" class="headerlink" title="npm info"></a>npm info</h3><p>npm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore</span><br></pre></td></tr></table></figure></p>
<p>上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm info underscore description</span><br><span class="line"></span><br><span class="line">$ npm info underscore homepage</span><br><span class="line"></span><br><span class="line">$ npm info underscore version</span><br></pre></td></tr></table></figure></p>
<h3 id="npm-search"><a href="#npm-search" class="headerlink" title="npm search"></a>npm search</h3><p>npm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm search &lt;搜索词&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="npm-list"><a href="#npm-list" class="headerlink" title="npm list"></a>npm list</h3><p>npm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 global 参数，会列出全局安装的模块</span></span><br><span class="line">$ npm list -global</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm list 命令也可以列出单个模块</span></span><br><span class="line">$ npm list underscore</span><br></pre></td></tr></table></figure></p>
<h3 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h3><p>使用 npm 安装包的命令格式为：<br><code>npm [install/i] [package_name]</code></p>
<h4 id="本地模式和全局模式"><a href="#本地模式和全局模式" class="headerlink" title="本地模式和全局模式"></a>本地模式和全局模式</h4><p>npm 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">http://npmjs.org</a> 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。<br>如果你熟悉 Ruby 的 gem 或者 Python 的 pip，你会发现 npm 与它们的行为不同，gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>
<p>我们在使用 supervisor 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 supervisor 。</p>
<p>这里注意一点的就是，supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 supervisor 来启动服务了。<br>supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node.js 。</p>
<p>一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为<strong>本地模式不会注册 PATH 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。</p>
<p>本地模式和全局模式的特点如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">可通过 require 使用</th>
<th style="text-align:center">注册 PATH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">本地模式</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">全局模式</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本地安装</span></span><br><span class="line">$ npm install &lt;package name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">$ sudo npm install -global &lt;package name&gt;</span><br><span class="line">$ sudo npm install -g &lt;package name&gt;</span><br></pre></td></tr></table></figure>
<p>npm install 也支持直接输入 Github 代码库地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install git://github.com/package/path.git</span><br><span class="line">$ npm install git://github.com/package/path.git<span class="comment">#0.1.0</span></span><br></pre></td></tr></table></figure></p>
<p>安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>
<p>如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 –force 参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install &lt;packageName&gt; --force</span><br></pre></td></tr></table></figure></p>
<h4 id="安装不同版本"><a href="#安装不同版本" class="headerlink" title="安装不同版本"></a>安装不同版本</h4><p>install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax@latest</span><br><span class="line">$ npm install sax@0.1.1</span><br><span class="line">$ npm install sax@<span class="string">"&gt;=0.1.0 &lt;0.2.0"</span></span><br></pre></td></tr></table></figure></p>
<p>install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。</p>
<blockquote>
<p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install sax --save</span><br><span class="line">$ npm install node-tap --save-dev</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ npm install sax -S</span><br><span class="line">$ npm install node-tap -D</span><br></pre></td></tr></table></figure>
<h5 id="dependencies-依赖"><a href="#dependencies-依赖" class="headerlink" title="dependencies 依赖"></a>dependencies 依赖</h5><p>这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 npm install 命令的时候，npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"markdown-it"</span>: <span class="string">"^8.1.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="devDependencies-开发依赖"><a href="#devDependencies-开发依赖" class="headerlink" title="devDependencies 开发依赖"></a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"autoprefixer"</span>: <span class="string">"^6.4.0"</span>,<span class="number">0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-preset-es2015<span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-preset-stage<span class="number">-2</span><span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>babel-register<span class="string">": "</span>^<span class="number">6.0</span><span class="number">.0</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack<span class="string">": "</span>^<span class="number">1.13</span><span class="number">.2</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-dev-middleware<span class="string">": "</span>^<span class="number">1.8</span><span class="number">.3</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-hot-middleware<span class="string">": "</span>^<span class="number">2.12</span><span class="number">.2</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>webpack-merge<span class="string">": "</span>^<span class="number">0.14</span><span class="number">.1</span><span class="string">",</span></span><br><span class="line"><span class="string">    "</span>highlightjs<span class="string">": "</span>^<span class="number">9.8</span><span class="number">.0</span><span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>当你有了一个完整的 package.json 文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。</p>
<p>npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 –production 参数，可以只安装 dependencies 字段的模块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --production</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ NODE_ENV=production npm install</span><br></pre></td></tr></table></figure></p>
<p>一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backbone = <span class="built_in">require</span>(<span class="string">'backbone'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(backbone.VERSION)</span><br></pre></td></tr></table></figure></p>
<h3 id="npm-run"><a href="#npm-run" class="headerlink" title="npm run"></a>npm run</h3><p>npm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。<br>package.json<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"jshint"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"browserify"</span>: <span class="string">"latest"</span>,</span><br><span class="line">    <span class="string">"mocha"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"jshint **.js"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"mocha test/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="scripts-脚本"><a href="#scripts-脚本" class="headerlink" title="scripts 脚本"></a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 package.json 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br>npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"node build/dev-server.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">    <span class="string">"docs"</span>: <span class="string">"node build/docs.js"</span>,</span><br><span class="line">    <span class="string">"build-docs"</span>: <span class="string">"npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m 'auto-pages' &amp; git push &amp; git checkout master"</span>,</span><br><span class="line">    <span class="string">"build-publish"</span>: <span class="string">"rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push"</span>,</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。<br>npm 内置了两个命令简写， npm test 等同于执行 npm run test，npm start 等同于执行 npm run start。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build"</span>: <span class="string">"npm run build-js &amp;&amp; npm run build-css"</span></span><br></pre></td></tr></table></figure>
<p>上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。</p>
<p>写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> site/main</span><br><span class="line">browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</span><br></pre></td></tr></table></figure></p>
<p>假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build-js"</span>: <span class="string">"bin/build.sh"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pre-和-post-脚本"><a href="#pre-和-post-脚本" class="headerlink" title="pre- 和 post- 脚本"></a>pre- 和 post- 脚本</h3><p>npm run 为每条命令提供了 pre- 和 post- 两个钩子（hook）。以 npm run lint 为例，执行这条命令之前，npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint，然后执行 npm run lint，最后执行 npm run postlint。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myproject"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"eslint"</span>: <span class="string">"latest"</span></span><br><span class="line">    <span class="string">"karma"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint --cache --ext .js --ext .jsx src"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"karma start --log-leve=error karma.config.js --single-run=true"</span>,</span><br><span class="line">    <span class="string">"pretest"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">    <span class="string">"posttest"</span>: <span class="string">"echo 'Finished running tests'"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。</p>
<ol>
<li>pretest</li>
<li>test</li>
<li>posttest</li>
</ol>
<p>如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。</p>
<h3 id="npm-bin"><a href="#npm-bin" class="headerlink" title="npm bin"></a>npm bin</h3><p>npm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下执行</span></span><br><span class="line">$ npm bin</span><br><span class="line">./node_modules/.bin</span><br></pre></td></tr></table></figure></p>
<h1 id="创建全局链接"><a href="#创建全局链接" class="headerlink" title="创建全局链接"></a>创建全局链接</h1><p>npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 express，这时在工程的目录下运行命令：<br><code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p>
<h1 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h1><p>包是在模块基础上更深一步的抽象，Node.js 的包类似于 C/C++ 的函数库或者 Java、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。<br>Node.js 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征：<br>。package.json 必须在包的顶层目录下；<br>。二进制文件应该在 bin 目录下；<br>。JavaScript 代码应该在 lib 目录下；<br>。文档应该在 doc 目录下；<br>。单元测试应该在 test 目录下。</p>
<p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p>
<p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p>
<p>Node.js 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>
<p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：<br><span id="inline-yellow">name</span>: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br><span id="inline-blue">description</span>: 包的简要说明。<br><span id="inline-green">version</span>: 符合语义化版本识别规范的版本字符串。<br><span id="inline-red">keywords</span>: 关键字数组，通常用于搜索。<br><span id="inline-purple">maintainers</span>: 维护者数组，每个元素要包含 name 、email(可选)、web(可选)字段。<br><span id="inline-yellow">contributors</span>: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。<br><span id="inline-blue">bugs</span>: 提交 bug 的地址，可以是网址或者电子邮件地址。<br><span id="inline-green">licenses</span>: 许可证数组，每个元素要包含 type（许可证的名称）和 url（链接到许可证文本的地址）字段。<br><span id="inline-red">repositories</span>: 仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br><span id="inline-purple">dependencies</span>: 包的依赖，一个关联数组，由包名称和版本号组成。</p>
<h1 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h1><p>通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建<br>完成后可以使用 npm whoami 检测是否已经取得了账号。<br>接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">http://search.npmjs.org/</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。<br>如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish 命令就行了。<br>如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。</p>
<p id="div-border-top-yellow"><em>需要说明的是：json 文件不能有注释</em><br></p>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://javascript.ruanyifeng.com/nodejs/npm.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/npm.html</a></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>npm version  查看npm和node的版本<br>npm list –depth=0 [-g]  查看[全局]安装的包<br>npm root [-g]  查看[全局的]包的安装路径</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> npm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AMD，CMD 规范详解]]></title>
      <url>https://jiechengyang.github.io/2017/03/20/amd-cmd/</url>
      <content type="html"><![CDATA[<p>当我们了解了 <a href="https://neveryu.github.io/2017/03/07/commonjs/" target="_blank" rel="noopener">CommonJS</a> 以后，<code>CommonJS</code> 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<br>由于 <code>Node.js</code> 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 <code>CommonJS</code> 规范比较适用。<br>但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式。为什么呢？</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>第二行 <code>math.add(2, 3)</code>，在第一行 <code>require(&#39;math&#39;)</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>对于浏览器，这是一个大问题，因为模块都放在服务器端。等待时间取决于网速的快慢，可能要等很长时间，浏览器处理“假死”状态。</p>
<p>因此，浏览器端的模块，不能采用“同步加载”，只能采用“异步加载”。</p>
<h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p><a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a> 则是异步加载模块，允许指定回调函数。因此浏览器端一般采用 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>。<br><code>AMD(Asynchronous module definition)</code>： <span id="inline-green">异步模块定义。</span></p>
<p>类似的还有 <code>CommonJS Modules/2.0</code> 规范，是 <code>BravoJS</code> 在推广过程中对模块定义的规范化产出。<br><code>CMD(Common module definition)</code>：<span id="inline-blue">通用模块定义。</span></p>
<p>目前这些规范的实现都能达成<strong>浏览器端模块化开发的目的</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务端JS</th>
<th style="text-align:center">浏览器端JS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相同的代码需要多次执行</td>
<td style="text-align:center">代码需要从一个服务器端分发到多个客户端执行</td>
</tr>
<tr>
<td style="text-align:center">CPU 和内存资源是瓶颈</td>
<td style="text-align:center">宽带是瓶颈</td>
</tr>
<tr>
<td style="text-align:center">加载时从磁盘中加载</td>
<td style="text-align:center">加载时需要通过网络加载</td>
</tr>
</tbody>
</table>
<p>AMD 的诞生，就是为了解决这两个问题：<br>1.实现 js 文件的异步加载，避免网页失去响应<br>2.管理模块之间的依赖性，便于代码的编写和维护</p>
<p>AMD(异步模块定义)主要为前端 JS 的表现指定规范。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD 也采用 <a href="https://github.com/amdjs/amdjs-api/wiki/require" target="_blank" rel="noopener">require()</a> 语句加载模块，但是不同于 CommonJS，它要求两个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数 callback，则是加载成功之后的回调函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>实现 AMD 规范的加载器其实是挺多的，目前，主要有两个 Javascript 库实现了 AMD 规范：<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 和 <a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。不过多数人还是用 require.js 。<br>另外如果对 ES6 的模块感兴趣，可以考虑 <a href="http://github.com/hax/my.js" target="_blank" rel="noopener">my.js</a> ，是按照 ES6 草案的 module/loader 规范实现的。</p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 在推广过程中对模块定义的规范化产出。</p>
<p>推荐学习 <a href="http://requirejs.org/" target="_blank" rel="noopener">require.js</a>。</p>
<h2 id="AMD-模块的写法"><a href="#AMD-模块的写法" class="headerlink" title="AMD 模块的写法"></a>AMD 模块的写法</h2><p><a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，采用 AMD 规范。也就是说，模块必须按照 AMD 的规定来写。<br>具体来说，就是模块必须采用特定的 define() 函数来定义。如果一个模块不依赖其他模块。那么可以直接定义在 define() 函数之中。<br>假定现在有一个 math.js 文件，它定义了一个 math 模块。那么，math.js 就要这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> x+y;</span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　add: add</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>加载方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">　alert(math.add(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果这个模块还依赖其他模块，那么 define() 函数的第一个参数，必须是一个数组，指明该模块的依赖性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'myLib'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">myLib</span>)</span>&#123;</span><br><span class="line">　<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　myLib.doSomething();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="keyword">return</span> &#123;</span><br><span class="line">　　foo : foo</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当 require() 函数加载上面这个模块的时候，就会先加载 myLib.js 文件。</p>
<h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a>加载非规范的模块</h2><p>理论上，<a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener">require.js</a> 加载的模块，必须是按照 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md" target="_blank" rel="noopener">AMD 规范</a>、用 define() 函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如 jQuery ）符合 AMD 规范，更多的库并不符合。那么，require.js 是否能够加载非规范的模块呢？<br>回答是可以的。<br>这样的模块在用 require() 加载之前，要先用 require.config() 方法，定义它们的一些特征。<br>举例来说，underscore 和 backbone 这两个库，都没有采用 AMD 规范编写。如果要加载它们的话，必须先定义它们的特征。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">　shim: &#123;</span><br><span class="line">　　<span class="string">'underscore'</span>: &#123;</span><br><span class="line">　　　exports: <span class="string">'_'</span></span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">'backbone'</span>: &#123;</span><br><span class="line">　　　deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],</span><br><span class="line">　　　exports: <span class="string">'Backbone'</span></span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>require.config() 接受一个配置对象，这个对象除了有前面说过的 paths 属性之外，还有一个 shim 属性，专门用来配置不兼容的模块。具体来说，每个模块要定义：<br>（1）exports 值（输出的变量名），表明这个模块外部调用时的名称；<br>（2）deps 数组，表明该模块的依赖性。<br>比如，jQuery 的插件可以这样定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shim: &#123;</span><br><span class="line">　<span class="string">'jquery.scroll'</span>: &#123;</span><br><span class="line">　　deps: [<span class="string">'jquery'</span>],</span><br><span class="line">　　exports: <span class="string">'jQuery.fn.scroll'</span></span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">CMD</a> 是 <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">sea.js</a> 在推广过程中对模块定义的规范化产出。</p>
<h3 id="CMD-模块定义"><a href="#CMD-模块定义" class="headerlink" title="CMD 模块定义"></a>CMD 模块定义</h3><p>在 CMD 规范中，一个模块就是一个文件。define 是一个全局函数，用来定义模块。<br>define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。<br>factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以定义一个 JSON 数据模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>也可以通过字符串定义模板模块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">'I am a template.My name is &#123;&#123;name&#125;&#125;.'</span>);</span><br></pre></td></tr></table></figure></p>
<p>factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。<br>factory 是一个函数，有三个参数，function(require, exports, module)<br>1、require 是一个方法，接受模块标识作为唯一参数，用来获取其他模块提供的接口：require(id)<br>2、exports 是一个对象，用来向外提供模块接口<br>3、module 是一个对象，上面存储了与当前模块相关联的一些属性和方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  <span class="comment">// 依赖就近书写，什么时候用到什么时候引入</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>建议写一写 SeaJS 的 CMD 规范，与 AMD 非常类似，在国内的影响力非常大，但是个人觉得 SeaJS 比 RequireJS 好很多，另外由于是国人开发的，交流也非常方便，可以看到 github 上的更新、互动非常频繁。</p>
<h1 id="AMD-与-CMD-的区别"><a href="#AMD-与-CMD-的区别" class="headerlink" title="AMD 与 CMD 的区别"></a>AMD 与 CMD 的区别</h1><p>区别：</p>
<ol>
<li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li>
<li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CommonJS 详细介绍]]></title>
      <url>https://jiechengyang.github.io/2017/03/07/commonjs/</url>
      <content type="html"><![CDATA[<h2 id="CommonJS-规范与实现"><a href="#CommonJS-规范与实现" class="headerlink" title="CommonJS 规范与实现"></a>CommonJS 规范与实现</h2><p>正如当年为了统一 JavaScript 语言标准，人们制定了 ECMAScript 规范一样，如今为了统一 JavaScript 在浏览器之外的实现，CommonJS 诞生了。CommonJS 试图定义一套普通应用程序使用的 API，从而填补 JavaScript 标准库过于简单的不足。CommonJS 的终极目标是制定一个像 C++ 标准库一样的规范，使得基于 CommonJS API 的应用程序可以在不同的环境下运行，就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立，CommonJS 不参与标准库实现，其实现交给像 Node.js 之类的项目来完成。下图是 CommonJS 的各种实现。</p>
<a id="more"></a>
<p><img src="http://i2.muimg.com/567571/abd3d52d96d4db7c.png" alt="ConmonJS 的实现"></p>
<p>CommonJS 规范包括了模块（modules）、包（packages）、系统（system）、二进制（binary）、控制台（console）、编码（encodings）、文件系统（filesystems）、套接字（sockets）、单元测试（unit testing）等部分。</p>
<p>Node.js 是目前 CommonJS 规范最热门的一个实现，它基于 CommonJS 的 Modules/1.0 规范实现了 Node.js 的模块，同时随着 CommonJS 规范的更新，Node.js 也在不断跟进。</p>
<p>模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正式为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的 script 标签来实现。Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。</p>
<h2 id="CommonJS-规范的实现"><a href="#CommonJS-规范的实现" class="headerlink" title="CommonJS 规范的实现"></a>CommonJS 规范的实现</h2><p>Node.js 的模块和包机制的实现参照了 CommonJS 的标准，但并未完全遵循。不过两者的区别不大，一般来说你大可不必担心，只有当你试图制作一个除了支持 Node.js 之外还要支持其他平台的模块或包的时候才需要仔细研究。通常，两者没有直接冲突的地方。</p>
<p>我们经常把 Node.js 的模块和包相提并论，因为模块和包是没有本质区别的，两个概念也时常混用。如果要辨析，那么可以<strong>把包理解成是实现了某个功能模块的集合</strong>，用于发布和维护。对使用者来说，模块和包的区别是透明的，因此经常不作区分。</p>
<p>CommonJS 规范规定，每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。加载某个模块，其实是加载该模块的 module.exports 属性。</p>
<p>为了方便，Node.js 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行这样的命令：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure></p>
<p>注意，不能直接将 exports 变量指向一个值，因为这样等于切断了 exports 与 module.exports 的联系。</p>
<p><strong>如果你觉得，exports 与 module.exports 之间的区别很难分清，一个简单的处理办法，就是放弃使用 exports，只使用 module.exports。</strong></p>
<h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、JSON 或者编译过的 C/C++ 扩展。</p>
<h2 id="创建及加载模块"><a href="#创建及加载模块" class="headerlink" title="创建及加载模块"></a>创建及加载模块</h2><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。<br>让我以一个例子来了解模块。创建一个 module.js 文件，内容是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line">exports.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</span><br><span class="line">    name = thyName;</span><br><span class="line">&#125;;</span><br><span class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在同一目录下创建 getmodule.js，内容是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getmodule.js</span></span><br><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line">myModule.setName(<span class="string">'Yu'</span>);</span><br><span class="line">myModule.sayHello();</span><br></pre></td></tr></table></figure>
<p>运行 <code>node getmodule.js</code> ，结果是：</p>
<blockquote>
<p>Hello Yu</p>
</blockquote>
<p>module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getmodule.js 中通过 <code>require(&#39;./module&#39;)</code> 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。</p>
<h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><blockquote>
<p>在 Node.js 中，我们可以直接通过 require 获取核心模块，例如 <code>require(&#39;fs&#39;)</code> 。核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块。</p>
</blockquote>
<p>如果有模块与核心模块命名冲突，Node.js 为什么可以选择加载核心模块呢？require 的实现机制是怎样的呢？</p>
<h4 id="1、按路径加载模块"><a href="#1、按路径加载模块" class="headerlink" title="1、按路径加载模块"></a>1、按路径加载模块</h4><p>如果 require 参数以 “/“ 开头，那么就以绝对路径的方式查找模块名称，例如 <code>require(&#39;/home/neveryu/module&#39;)</code> 将会按照 优先级依次尝试加载 <code>/home/neveryu/module.js</code>、<code>/home/neveryu/module.json</code> 和 <code>/home/neveryu/module.node</code>。</p>
<p>如果 require 参数 “./“ 或 “../“ 开头，那么则以相对路径的方式查找模块，这种方式在应用中是最常见的。例如前面的例子中我们用了 <code>require(&#39;./hello&#39;)</code>来加载同一文件夹下的 hello.js。</p>
<h4 id="2、通过查找-node-modules-目录加载模块"><a href="#2、通过查找-node-modules-目录加载模块" class="headerlink" title="2、通过查找 node_modules 目录加载模块"></a>2、通过查找 node_modules 目录加载模块</h4><p>如果 require 参数不以 “/“ ， “./“ 或 “../“ 开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。我们使用 npm 获取的包通常就是以这种方式加载的。<br>在 node_modules 目录的外面一层，外面可以直接使用 <code>require(&#39;express&#39;)</code> 来代替 <code>require(&#39;./node_modules/express&#39;)</code>。这是 Node.js 模块加载的一个重要特征：通过查找 node_modules 目录来加载模块。<br>我们不仅要在 project 目录下的 app.js 中使用 <code>require(&#39;express&#39;)</code>，而且可能要在 controllers 子目录下的 index_controller.js 中也使用 <code>require(&#39;express&#39;)</code>，这时就需要向父目录上溯一层才能找到 node_modules 中的 express 了。</p>
<h4 id="3、加载缓存"><a href="#3、加载缓存" class="headerlink" title="3、加载缓存"></a>3、加载缓存</h4><p>Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。注意，Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的，也就是说即使你分别通过 <code>require(&#39;express&#39;)</code> 和 <code>require(&#39;./node_modules/express&#39;)</code>加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。</p>
<h3 id="单次加载"><a href="#单次加载" class="headerlink" title="单次加载"></a>单次加载</h3><p>上面这个例子有点类似于创建一个对象，但实际上和对象又有本质的区别，因为 require 不会重复加载模块，也就是说无论调用多少次 require，获得的模块都是同一个。我们在 getmodule.js 的基础上稍作修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadmodule.js</span></span><br><span class="line"><span class="keyword">var</span> hello1 = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line">hello1.setName(<span class="string">'Yu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello2 = <span class="built_in">require</span>(<span class="string">'./module'</span>);</span><br><span class="line">hello2.setName(<span class="string">'Yu 2'</span>);</span><br><span class="line"></span><br><span class="line">hello1.sayHello();</span><br></pre></td></tr></table></figure></p>
<p>运行后发现输出结果是 Hello Yu 2，这是因为变量 hello1 和 hello2 指向的是同一个实例，因此 hello1.setName 的结果被 hello2.setName 覆盖，最终输出结果是由后者决定的。</p>
<h3 id="覆盖-exports"><a href="#覆盖-exports" class="headerlink" title="覆盖 exports"></a>覆盖 exports</h3><p>有时候我们只是想把一个对象封装到模块中，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singleobjct.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">thyName</span>) </span>&#123;</span><br><span class="line">        name = thyName;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.Hello = Hello;</span><br></pre></td></tr></table></figure></p>
<p>此时我们在其他文件中需要通过 <code>require(&#39;./singleobject&#39;).Hello</code> 来获取 Hello 对象，这略显冗余，可以用下面方法稍微简化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123;</span><br><span class="line">    name = thyName;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以直接获得这个对象了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gethello.js</span></span><br><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line">hello = <span class="keyword">new</span> Hello();</span><br><span class="line">hello.setName(<span class="string">'Yu'</span>);</span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="CommonJS-模块的特点如下："><a href="#CommonJS-模块的特点如下：" class="headerlink" title="CommonJS 模块的特点如下："></a>CommonJS 模块的特点如下：</h3><ol>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>独立性是模块的重要特点就，模块内部最好不与程序的其他部分直接交互。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ol>
<h3 id="CommonJS-中的-Require"><a href="#CommonJS-中的-Require" class="headerlink" title="CommonJS 中的 Require"></a>CommonJS 中的 Require</h3><p>建议阅览：<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1#Require" target="_blank" rel="noopener">CommonJS require 规范</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何解决内存泄漏引发的血案]]></title>
      <url>https://jiechengyang.github.io/2017/02/28/memory-leak/</url>
      <content type="html"><![CDATA[<p>之前做了一个谷歌浏览器的插件开发，它会打开一个链接，然后收集数据并上传。依次循环，但是跑的时间久了，内存就变得很高，然后浏览器就会变卡，慢慢的影响这个插件的运行，最后浏览器也会崩溃。</p>
<h1 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h1><p>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在 C++ 中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的 C# 和 Java 等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。</p>
<a id="more"></a>
<p>自动垃圾收集是不能代替有效的内存管理的，特别是在大型，长时间运行的Web应用程序中。</p>
<h1 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h1><p>1、Delete 一个 Object 的属性会让此对象变慢<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="string">'y'</span>&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj;  <span class="comment">// 此时 obj 会成一个慢对象</span></span><br><span class="line">obj.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="string">'y'</span>&#125;;</span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">// 应该这样</span></span><br></pre></td></tr></table></figure></p>
<p>2、闭包<br>1）在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。<br>2）闭包可以维持函数内局部变量，使其得不到释放。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> largeStr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'x'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> largeStr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<p>3、DOM 泄漏<br>当原有的 DOM 被移除时，子节点引用没有被移除则无法回收<br>当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在 IE 中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄漏。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBth"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">'test memory'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应改成下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBth"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  btn.onclick = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">'test memory'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、Timers 计(定)时器泄漏<br>定时器也是常见产生内存泄露的地方<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">90000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    callAgain: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ref = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> val = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          ref.callAgain();</span><br><span class="line">        &#125;,<span class="number">90000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.callAgain();</span><br><span class="line">  <span class="comment">// 虽然你想回收但是 timer 还在</span></span><br><span class="line">  obj = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、jquery 的 html() 函数<br>页面中还需要注意的一点是使用 jquery 的 html() 函数，该函数不是基于 innerHTML 实现的，大量使用同样也会导致系统性能下降。</p>
<p>6、使用事件委托代替事件注册<br>页面中如果元素过多，且需要为每个元素注册相同的 click 事件，这个时候我们优先考虑到使用委托机制，将需要注册的 click 事件注册到元素的上层或者顶层元素，这样我们就节省了大量的 click 注册事件。</p>
<p>7、自动类型装箱转换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test test"</span>;</span><br><span class="line">alert(s.length);</span><br></pre></td></tr></table></figure></p>
<p>s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JS 引擎会自动创建一个临时 String 对象封装 s，而这个对象一定会泄漏。这个 bug 匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显示转换一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test test"</span>;</span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">String</span>(s).length);</span><br></pre></td></tr></table></figure></p>
<h1 id="调试内存"><a href="#调试内存" class="headerlink" title="调试内存"></a>调试内存</h1><p>1、Timeline<br>Chrome 自带的内存调试工具可以很方便的查看内存使用情况和内存泄漏：<br>F12 -&gt; Timeline -&gt; Memory<br>点击 record 即可开始收集，点击弹出框的 Finish 即停止，然后会统计出 record 到 Finish 这一段时间内的内存使用情况。</p>
<p>2、Profiles<br>Chrome 自带的 Profiles 可以记录当前的内存使用情况<br>F12 -&gt; Profiles -&gt; Take Heap Snapshot<br>点击 Take Snapshot 就可以拍下当前 JS 的 heap 快照。<br><em>注意：每次拍快照前，都会先自动执行一个 GC，所以在视图里的对象都是可及的。</em></p>
]]></content>
      
        <categories>
            
            <category> 综合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 内存管理 & 垃圾回收机制]]></title>
      <url>https://jiechengyang.github.io/2017/02/18/js-memory-management-and-gc/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>低级语言，比如C，有低级的内存管理基元，像 malloc()，free()。另一方面，JavaScript 的内存基元在变量（对象，字符串等等）创建时分配，然后在他们不再被使用时“自动释放”。后者被称为垃圾回收。这个“自动”是混淆并给 JavaScript （和其他高级语言）开发者一个错觉：他们可以不用考虑内存管理。</p>
<a id="more"></a>
<h1 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h1><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>为了不让程序员为分配费心，JavaScript 在定义变量时完成内存分配。<br>例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;  <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为对象及其包含变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">obj.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  obj.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="通过函数调用的内存分配"><a href="#通过函数调用的内存分配" class="headerlink" title="通过函数调用的内存分配"></a>通过函数调用的内存分配</h2><p>有些函数调用结果是分配对象内存：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="值的使用"><a href="#值的使用" class="headerlink" title="值的使用"></a>值的使用</h2><p>使用值的过程实际上是对分配内存进行读取与写入的操作，这意味着可以写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<h2 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h2><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
<p>高级语言解释器嵌入了“垃圾回收器”，主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这个过程是一个近似的，因为要知道某块内存是否需要是 <a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29" target="_blank" rel="noopener">无法判定的</a> （无法被某种算法所解决）。</p>
<h1 id="垃圾回收机制——GC"><a href="#垃圾回收机制——GC" class="headerlink" title="垃圾回收机制——GC"></a>垃圾回收机制——GC</h1><p>JavaScript 具有自动垃圾回收机制（GC:Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</p>
<p>JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>
<p>不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。</p>
<p>还是上代码说明吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'yu'</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'yu'</span>, <span class="attr">age</span>: <span class="number">11</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fn1();</span><br><span class="line"><span class="keyword">var</span> b = fn2();</span><br></pre></td></tr></table></figure></p>
<p>我们来看代码是如何执行的。首先定义了两个 function,分别叫做 fn1 和 fn2，当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象，而当调用结束后，出了 fn1 的环境，那么该块内存会被 js 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放。</p>
<p>这里问题就出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个而变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>Netscape Navigator3 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">    a.pro = b;</span><br><span class="line">    b.pro = a;</span><br><span class="line">&#125; </span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境，在标记清除方式下是没有问题的，但是在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。<br>最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.element = <span class="literal">null</span>;</span><br><span class="line">element.o = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>1、什么时候触发垃圾回收？<br>垃圾回收周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64K 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。</p>
<p>微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多。</p>
<p>2、合理的 GC 方案<br>1）、JavaScript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即：</p>
<ul>
<li>遍历所有可访问的对象。</li>
<li>回收已不可访问的对象。</li>
</ul>
<p>2）、GC 的缺陷<br>和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 JavaScript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一般不用 setInterval，而用 setTimeout 的延时递归来代替 interval。<br>setInterval 会产生回调堆积，特别是时间很短的时候。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>setInterval 有个很烦的地方就是当 js 主程序空闲的时候，执行代码队列里面的代码的时候，如果此时候我们有一个问题，定时器是等到回调执行完，才开始计时进行下次循环呢？还是只要一次计时完毕，插入回调之后不管回调执不执行就开始计时呢？答案显示是后者，这也就是我说 setInterval 坑的原因啊，因为这会出现一种情况，当我们插入回调的时候前队列有别的代码在执行，这时候回调肯定是不会执行的，因此如果这个时候无限定时时间到了会再次插入回调，这个时候如果发现队列中的第一次回调没有执行，那么再次插入的回调浏览器就默认取消，（这是以防出现回调连续执行多次的情况）但是这又引发了新的情况就是有些回调是不能取消掉的？</p>
]]></content>
      
        <categories>
            
            <category> 综合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[polyfill — Respond.js]]></title>
      <url>https://jiechengyang.github.io/2017/02/11/respond-js/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Respond.js 让不支持 css3 Media Query 的浏览器包括 IE6-IE8 等其他浏览器支持媒体查询。</p>
</blockquote>
<p>Respond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 <code>min-width</code> 和 <code>max-width</code>特性，实现响应式网页设计（Responsive Web Design）。</p>
<a id="more"></a>
<p>响应式布局，理想状态是，对 <code>PC/移动</code> 各种终端进行响应。媒体查询的支持程度是 IE9+ 以及其他现代的浏览器，但是 IE8 在市场当中仍然占据了比较大量的市场份额，使我们不得不进行 IE 低端浏览器的考虑。那么如何在 IE6~8 浏览器中兼容响应式布局呢？<br>这里我们需要借助这样一个文件：<code>respond.js</code>.</p>
<p>文件下载地址：<a href="respond.js">respond.js</a>.</p>
<p>自己在阅读了官方文档之后，进行了一系列测试。友情提示各位朋友，关于 <strong>respond.js</strong> 的使用，有一些需要注意的地方，一旦不注意，在 IE6-8 中就无法显示出来。</p>
<h1 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h1><p>既然要实现响应式网页，那么就需要用到媒体查询，媒体查询的核心是 <code>min-width</code> 和 <code>max-width</code>,而 IE8 以下以及一些其它的浏览器不支持这两个属性，<strong>respond.js</strong> 是怎么做的呢？</p>
<ul>
<li>将 <code>&lt;head&gt;</code> 中所有外部引入的CSS文件路径取出来存储到一个数组当中；</li>
<li>遍历数组，并一个个发送 AJAX 请求；</li>
<li>AJAX 回调后，分析 response 中的 media query 的 <code>min-width</code> 和 <code>max-width</code> 语法（注意，仅仅支持 <code>min-width</code> 和 <code>max-width</code> ），分析出 viewport 变化区间对应相应的 css 块；</li>
<li>页面初始化时和 <code>window.resize</code> 时，根据当前 viewport 使用相应的 css 块。</li>
</ul>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>考虑到 IE9 是支持 CSS3 的，所以直接在 HTML 页面的 <code>&lt;head&gt;</code> 标签中添加脚本引入即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">      &lt;script src="js/respond.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>讲道理，我们是应该将 js 文件放在 html 文件的最后，但是 repond.js 文件，我还是建议你将它放在 <code>&lt;head&gt;</code> 中，并且放在 css 文件的后面。越早引入越好，在 IE 下面看到页面闪屏的概率就越低，因为最初 css 会先渲染出来，如果 respond.js 加载得很后面，这时重新根据 media query 解析出来的 css 会再改变一次页面的布局等，所以看起来有闪屏的现象.</p>
<h1 id="核心结论"><a href="#核心结论" class="headerlink" title="核心结论"></a>核心结论</h1><p>那么此时，就可以根据基本的实现思路，得到一些书写代码时要注意的地方：</p>
<ul>
<li>需要启动本地服务器（localhost），不能使用普通本地的url地址（file://开头）；</li>
<li>需要外部引入 CSS 文件，将 CSS 样式书写在 style 中是无效的；</li>
<li>由于 respond 插件是查找 CSS 文件，再进行处理，所以 respond.js 文件一定要放置在 CSS 文件的后面；</li>
<li>另外，虽然把 respond.js 放置在 <code>&lt;head&gt;</code> 里还是在 <code>&lt;body&gt;</code> 后面都能够实现，但是建议放置在 <code>&lt;head&gt;</code> 中（具体原因在下面的文档提示中有提到）；</li>
<li>最好不要为 CSS 设置 utf-8 的编码，使用默认（原因详见下面的文档提示部分）</li>
</ul>
<h1 id="文档提示"><a href="#文档提示" class="headerlink" title="文档提示"></a>文档提示</h1><p>在官方文档当中的一些提示：</p>
<ul>
<li>越早的引入 respond.js 文件，也就越可能避免 IE 下出现的闪屏。</li>
<li>不支持嵌套的媒体查询。</li>
<li>utf-8 的字符编码对 respond.js 文件的运行有影响。<br>官方API原文：<br><code>if CSS files are encoded in UTF-8 with Byte-Order-Mark, they will not work with Respond.js in IE7 or IE8.</code><br>基本含义就是：<strong>utf-8 格式的 CSS 文件字符编码会对插件造成影响</strong><br>但是在我使用 IE6-8 进行测试的时候，都能够正常显示（无论是在 css 文件中增加 charset 设置还是在 link 标签中增加 charset 设置）。因此，并不是太清楚这个位置 bug 的含义。</li>
<li>跨域可能会出现闪屏（还没有测试，具体情况不详）</li>
</ul>
<h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><ol>
<li><p>Respond.js 和 跨域（cross-domain） CSS 的问题<br>如果Respond.js和CSS文件被放在不同的域名或子域名下面（例如，使用CDN）时需要一些额外的设置。请参考Respond.js文档获取详细信息。</p>
</li>
<li><p>Internet Explorer 8 与 box-sizing<br>IE8 不能完全支持 <code>box-sizing: border-box;</code> 与 <code>min-width</code>、<code>max-width</code>、<code>min-height</code> 或 <code>max-height</code> 一同使用。由于此原因，从 Bootstrap v3.0.1 版本开始，我们不再为 <code>.container</code> 使用 <code>max-width</code>。</p>
</li>
<li><p>IE兼容模式<br>Bootstrap 不支持 IE 的兼容模式。为了让 IE 浏览器运行最新的渲染模式，建议将此 标签加入到你的页面中：<br><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt;</code><br>此标签被加入到所有文档页面和案例页面中，以确保在每个被支持的 IE 浏览器中保持最好的页面展现效果。</p>
</li>
<li><p>Respond.js 和 @import<br>Respond.js 不支持通过 @import 引入的 CSS 文件。例如，Drupal 一般被配置为通过 @import 引入 CSS 文件，Respond.js 对其将无法起到作用。</p>
</li>
</ol>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>从 respond.js 的工作原理可以知道，它将 <code>&lt;head&gt;</code> 中所有外部引入的 CSS 文件路径取出来存储到一个数组当中；然后遍历数组，并一个个发送 AJAX 请求；可以看出这里必须依赖 ajax 请求 css 路径才能得到 css 文件中的 media query 的内容，那 ajax 的跨域问题就要解决了；</p>
<p>由于我们的静态资源都是要放在 cdn 的，responds.js 也给出了跨域方法，即引入代理页面：</p>
<p>//把 cross-domain/respond-proxy.html 放到cdn上<br>//把 cross-domain/respond.proxy.gif 放到当前域服务器上</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Respond.js proxy on external server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://externalcdn.com/respond-proxy.html"</span> <span class="attr">id</span>=<span class="string">"respond-proxy"</span> <span class="attr">rel</span>=<span class="string">"respond-proxy"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Respond.js redirect location on local server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/path/to/respond.proxy.gif"</span> <span class="attr">id</span>=<span class="string">"respond-redirect"</span> <span class="attr">rel</span>=<span class="string">"respond-redirect"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Respond.js proxy script on local server --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/respond.proxy.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="其他的支持响应式布局的插件-css3-dediaqueries-js"><a href="#其他的支持响应式布局的插件-css3-dediaqueries-js" class="headerlink" title="其他的支持响应式布局的插件  css3-dediaqueries.js"></a>其他的支持响应式布局的插件  css3-dediaqueries.js</h1><p>css3-mediaqueries.js 支持几乎所有的 media query 的语法。会出现闪屏。并不是很推荐使用，虽然能够支持全部的 media queries,但 <code>min-width</code> 和 <code>max-width</code> 其实就可以满足我们对响应式布局的需要。</p>
<h1 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h1><p>if CSS files are encoded in UTF-8 with Byte-Order-Mark,they will not work with Repond.js in IE7 or IE8.</p>
<p>也就是说保存格式应该是 utf-8 无 BOM 格式，BOM 会影响程序对文档的处理，正常的 utf-8 文档应该没事。</p>
<h1 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h1><p><strong>always link stylesheets or write inline CSS before js scripts.</strong></p>
<p>Respond.js on Github： <a href="https://github.com/scottjehl/Respond" target="_blank" rel="noopener">https://github.com/scottjehl/Respond</a>.</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[腻子脚本 — HTML5Shiv]]></title>
      <url>https://jiechengyang.github.io/2017/01/18/html5shiv/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/aFarkas/html5shiv" target="_blank" rel="noopener">HTML5shiv</a> is a javascript workaround to provide support for the new HTML 5 elements in IE Browsers older than IE 9.</p>
<ul>
<li>越来越多的站点开始使用 HTML5 标签。但是目前的情况是还有很多人在使用IE6，IE7，IE8。</li>
<li>而IE6，IE7，IE8是不能识别 HTML5 标签的。</li>
<li>这里提供一种让 IE 浏览器支持 HTML5 的方法，那就是使用 HTML5Shiv。</li>
<li>HTML5Shiv 主要解决 HTML5 提出的新的元素不被IE6-8识别。</li>
</ul>
<a id="more"></a>
<h1 id="为什么要使用-HTML5-的新标签"><a href="#为什么要使用-HTML5-的新标签" class="headerlink" title="为什么要使用 HTML5 的新标签"></a>为什么要使用 HTML5 的新标签</h1><ul>
<li><code>&lt;header&gt;</code> 定义页面或区段的头部</li>
<li><code>&lt;footer&gt;</code> 定义页面或区段的尾部</li>
<li><code>&lt;nav&gt;</code> 定义页面或区段的导航区域</li>
<li><code>&lt;section&gt;</code> 页面的逻辑区域或内容组合</li>
<li><code>&lt;article&gt;</code> 定义正文或一段完整的内容</li>
<li><code>&lt;aside&gt;</code> 定义补充或相关内容</li>
</ul>
<p>使用他们能让代码语义化更直观，而且更方便 SEO 优化，但是此 HTML5 新标签在 IE6/IE7/IE8 上并不能识别，需要 javascript 处理，所以我们就需要使用目前使用最广泛的 html5shiv.js 了，包括 Bootstrap 框架也是使用的这个来兼容低版本 IE 的。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>　　这些 HTML5 新元素不能被 IE6-8 识别，不能作为父节点包裹子元素，并且不能应用 CSS 样式。让 CSS 样式应用在未知元素上只需执行 <code>document.createElement(elementName)</code> 即可实现。HTML5Shiv 就是根据这个原理创建的。</p>
<p id="div-border-top-purple">关于 HTML5 不得不提 IE，在苹果、Google、Opera 和 Mozilla 等主流浏览器厂商积极参与新版本 HTML 标准的制定和推广时，微软却对 HTML5 规范不屑一顾。然而微软近期才表态要在 IE 中支持 HTML5,以致到今天为止的 IE8 及以下是无法支持 HTML5 标签的.</p>


<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>HTML5Shiv 的使用非常的简单，考虑到 IE9 是支持 HTML5 的，所以只需要在页面 head 中添加如下代码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">  &lt;script src=&quot;.js/html5shiv.js &quot;&gt;&lt;/script &gt;</span><br><span class="line">&lt;![endif]–-&gt;</span><br></pre></td></tr></table></figure></p>
<p>The syntax for the HTML5shiv is :<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src="./js/html5shiv.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="注意事项一"><a href="#注意事项一" class="headerlink" title="注意事项一"></a>注意事项一</h2><p>在引入了 html5shiv.js 以后，还需要在你自己的 css 文件中添加:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">dialog</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">menu</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是让这些 HTML5 标签成块状,像 div 那样。</p>
<p>No matter how ways what did you using, you should be initialize the new lable css.<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,<span class="selector-tag">dialog</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">menu</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="注意事项二"><a href="#注意事项二" class="headerlink" title="注意事项二"></a>注意事项二</h2><p>　　因为 html5shiv.js 是 JavaScript 文件，如果 IE6/7/8 禁用脚本的用户,那么就变成了无样式的”白板”网页,我们该怎么解决呢?<br>　　我们可以参照 Facebook 的做法，即引导用户进入带有 noscript 标识的页面，用 xhtml 标签替换 html5 标签，这要比为了保持兼容而写大量 hack 的作法更轻便一些。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lte IE 8]&gt; </span></span><br><span class="line"><span class="comment">&lt;noscript&gt;</span></span><br><span class="line"><span class="comment">&lt;style&gt;</span></span><br><span class="line"><span class="comment">  .html5-wrappers&#123;display:none!important;&#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt;</span></span><br><span class="line"><span class="comment">&lt;div class="ie-noscript-warning"&gt;您的浏览器禁用了脚本，请&lt;a href="#"&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href="/?noscript=1"&gt;继续访问&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/noscript&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样可以引导用户开启脚本，或者直接跳到 xhtml 标签设计的页面。</p>
<h2 id="注意事项三"><a href="#注意事项三" class="headerlink" title="注意事项三"></a>注意事项三</h2><ul>
<li>HTML5shiv is found within the <code>&lt;head&gt;</code> tag.</li>
<li>HTML5shiv is a javascript file that is referenced in a <code>&lt;script&gt;</code> tag.</li>
<li>You should usr HTML5shiv when you are using the new HTML5 element such as : <code>&lt;header&gt;</code>,<code>&lt;footer&gt;</code>,<code>&lt;nav&gt;</code>,<code>&lt;aside&gt;</code>,<code>&lt;article&gt;</code></li>
<li>Download the latest version of HTML5shiv from <a href="https://github.com/aFarkas/html5shiv/" target="_blank" rel="noopener">github</a> or reference the Open Source Software CDN version at <code>https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js</code> or <code>https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js</code>.</li>
<li>You will require the HTML5shiv to provide compatibility for IE Browser older than IE 9.</li>
</ul>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="HTML-5-Document"><a href="#HTML-5-Document" class="headerlink" title="HTML 5 Document"></a>HTML 5 Document</h3><p>If you created a new web page in HTML5,you would include the HTML5shiv as follows:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src=".js/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In this HTML 5 Document example,we have added HTML5shiv within the <head><meta name="generator" content="Hexo 3.9.0"> tag.In this case,the HTML5shiv is a javascript file called <strong>html5shiv.js</strong> found in the ./js directory.</head></p>
<p>If you did not want to download and store the HTML5shiv on your site,you could reference the version found on the Open Source Software CDN site.</p>
<h3 id="Support-two-CDN-site"><a href="#Support-two-CDN-site" class="headerlink" title="Support two CDN site"></a>Support two CDN site</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 5 Example by github.com/neveryu<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML 5 Example by github.com/neveryu<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.0/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注意事项四"><a href="#注意事项四" class="headerlink" title="注意事项四"></a>注意事项四</h2><h3 id="HTML-4-0-1-Transitional-Document"><a href="#HTML-4-0-1-Transitional-Document" class="headerlink" title="HTML 4.0.1 Transitional Document"></a>HTML 4.0.1 Transitional Document</h3><p>HTML5shiv does not apply to HTML 4.0.1 Transitional.</p>
<h3 id="XHTML-1-0-Transitional-Document"><a href="#XHTML-1-0-Transitional-Document" class="headerlink" title="XHTML 1.0 Transitional Document"></a>XHTML 1.0 Transitional Document</h3><p>HTML5shiv does not apply to XHTML 1.0 Transitional.</p>
<h3 id="XHTML-1-0-Strict-Document"><a href="#XHTML-1-0-Strict-Document" class="headerlink" title="XHTML 1.0 Strict Document"></a>XHTML 1.0 Strict Document</h3><p>HTML5shiv does not apply to XHTML 1.0 Strict.</p>
<h3 id="XHTML-1-1-Document"><a href="#XHTML-1-1-Document" class="headerlink" title="XHTML 1.1 Document"></a>XHTML 1.1 Document</h3><p>HTML5shiv does not apply to XHTML 1.1.</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>关于低版本浏览器不能识别 HTML5 标签的问题，除了使用 html5shiv.js 之外，还有一种做法就是为网站创建多套模版，通过程序对 User-Agent 的判断给不同的浏览器用户显示不同的页面，比如优酷网就是采用的这种模式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><a href="https://neveryu.github.io/2017/01/18/html5shiv/" target="_blank" rel="noopener">HTML5Shiv</a> and <a href="https://neveryu.github.io/2017/02/11/respond-js/" target="_blank" rel="noopener">Respond.js</a> for IE8 support of HTML5 elements and media queries.</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery使用技巧]]></title>
      <url>https://jiechengyang.github.io/2016/11/22/use-jquery-skill/</url>
      <content type="html"><![CDATA[<h3 id="禁用页面的右键菜单"><a href="#禁用页面的右键菜单" class="headerlink" title="禁用页面的右键菜单"></a>禁用页面的右键菜单</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  $(<span class="built_in">document</span>).bind(<span class="string">"contextmenu"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="新窗口打开页面"><a href="#新窗口打开页面" class="headerlink" title="新窗口打开页面"></a>新窗口打开页面</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span>&gt;</span>google_新窗口<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.google.com"</span> <span class="attr">rel</span>=<span class="string">"external"</span>&gt;</span>google_新窗口<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"demo1.html"</span>&gt;</span>当前窗口<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'a[href^="http://"]'</span>).attr(<span class="string">"target"</span>,<span class="string">"_blank"</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="输入框文字获取和失去焦点【推荐】"><a href="#输入框文字获取和失去焦点【推荐】" class="headerlink" title="输入框文字获取和失去焦点【推荐】"></a><font color="#099">输入框文字获取和失去焦点【推荐】</font></h3><a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"text1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span></span><br><span class="line"><span class="javascript">  $(<span class="string">"input.text1"</span>).val(<span class="string">"Enter your search text here."</span>);  </span></span><br><span class="line"><span class="javascript">  textFill( $(<span class="string">'input.text1'</span>) );  </span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">textFill</span>(<span class="params">input</span>)</span>&#123; <span class="comment">//input focus text function  </span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> originalvalue = input.val();  </span></span><br><span class="line"><span class="javascript">  input.focus( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>( $.trim(input.val()) == originalvalue )&#123;</span></span><br><span class="line"><span class="javascript">      input.val(<span class="string">''</span>); </span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="javascript">  &#125;).blur( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>( $.trim(input.val()) == <span class="string">''</span> )&#123; </span></span><br><span class="line">      input.val(originalvalue); </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="返回头部滑动动画"><a href="#返回头部滑动动画" class="headerlink" title="返回头部滑动动画"></a>返回头部滑动动画</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">jQuery.fn.scrollTo = <span class="function"><span class="keyword">function</span>(<span class="params">speed</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> targetOffset = $(<span class="keyword">this</span>).offset().top;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'html,body'</span>).stop().animate(&#123;<span class="attr">scrollTop</span>: targetOffset&#125;, speed);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="keyword">this</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="javascript"><span class="comment">// use</span></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#goheader"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">"body"</span>).scrollTo(<span class="number">500</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">&#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="获取鼠标位置"><a href="#获取鼠标位置" class="headerlink" title="获取鼠标位置"></a>获取鼠标位置</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"XY"</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).mousemove(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#XY'</span>).html(<span class="string">"X : "</span> + e.pageX + <span class="string">" | Y : "</span> + e.pageY);  </span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭所有-jQuery-动画效果"><a href="#关闭所有-jQuery-动画效果" class="headerlink" title="关闭所有 jQuery 动画效果"></a>关闭所有 jQuery 动画效果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fx.off = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="检测鼠标的右键和左键"><a href="#检测鼠标的右键和左键" class="headerlink" title="检测鼠标的右键和左键"></a>检测鼠标的右键和左键</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#box'</span>).mousedown(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(e.which);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="回车提交表单"><a href="#回车提交表单" class="headerlink" title="回车提交表单"></a>回车提交表单</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'input'</span>).keyup(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e.which == <span class="string">'13'</span>) &#123;</span><br><span class="line">      alert(<span class="string">'回车提交'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="切换复选框"><a href="#切换复选框" class="headerlink" title="切换复选框"></a>切换复选框</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tog = <span class="literal">false</span>;</span><br><span class="line">$(<span class="string">'button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"input[type=checkbox]"</span>).attr(<span class="string">"checked"</span>,!tog);</span><br><span class="line">  tog = !tog;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用-siblings-来选择同辈元素"><a href="#使用-siblings-来选择同辈元素" class="headerlink" title="使用 siblings() 来选择同辈元素"></a>使用 siblings() 来选择同辈元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不这样做</span></span><br><span class="line">$(<span class="string">'#nav li'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">'#nav li'</span>).removeClass(<span class="string">'active'</span>);</span><br><span class="line">  $(<span class="keyword">this</span>).addClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//替代做法是</span></span><br><span class="line">$(<span class="string">'#nav li'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).addClass(<span class="string">'active'</span>).siblings().removeClass(<span class="string">'active'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="为任何与选择器相匹配的元素绑定事件"><a href="#为任何与选择器相匹配的元素绑定事件" class="headerlink" title="为任何与选择器相匹配的元素绑定事件"></a>为任何与选择器相匹配的元素绑定事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"table"</span>).on(<span class="string">"click"</span>,<span class="string">"td"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  $(<span class="keyword">this</span>).toggleClass(<span class="string">"hover"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="proxy-的使用"><a href="#proxy-的使用" class="headerlink" title="$.proxy 的使用"></a>$.proxy 的使用</h3><p>使用回调方法的缺点之一是当执行类库中的方法后，上下文对象被设置到另外一个元素，比如，执行下面代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#panel</span> &#123;</span></span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panel"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'#panel'</span>).fadeIn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#panel button'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="keyword">this</span>).fadeOut();</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>你将遇到问题，button 元素会消失，而不是 panel 元素。可以使用 <code>$.proxy</code> 方法解决这个问题，代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#panel</span> &#123;</span></span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line"><span class="css">      <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"panel"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">'#panel'</span>).fadeIn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#panel button'</span>).click($.proxy(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="keyword">this</span>).fadeOut();</span></span><br><span class="line"><span class="javascript">    &#125;,<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样才正确执行。</p>
<h3 id="限制-Text-Area-域中的字符的个数"><a href="#限制-Text-Area-域中的字符的个数" class="headerlink" title="限制 Text-Area 域中的字符的个数"></a>限制 Text-Area 域中的字符的个数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"mytextarea"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    jQuery.fn.maxLength = <span class="function"><span class="keyword">function</span>(<span class="params">max</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> type = <span class="keyword">this</span>.tagName.toLowerCase();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> inputType = <span class="keyword">this</span>.type? <span class="keyword">this</span>.type.toLowerCase() : <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(type == <span class="string">"input"</span> &amp;&amp; inputType == <span class="string">"text"</span> || inputType == <span class="string">"password"</span>)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">//应用标准的maxLength</span></span></span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.maxLength = max;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">"textarea"</span>)&#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> ob = e || event;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> keyCode = ob.keyCode;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> hasSelection = <span class="built_in">document</span>.selection? <span class="built_in">document</span>.selection.createRange().text.length &gt; <span class="number">0</span> : <span class="keyword">this</span>.selectionStart != <span class="keyword">this</span>.selectionEnd;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> !(<span class="keyword">this</span>.value.length &gt;= max &amp;&amp; (keyCode &gt; <span class="number">50</span> || keyCode == <span class="number">32</span> || keyCode == <span class="number">0</span> || keyCode == <span class="number">13</span>) &amp;&amp; !ob.ctrlKey &amp;&amp; !ob.altKey &amp;&amp; !hasSelection);</span></span><br><span class="line">              &#125;;</span><br><span class="line"><span class="javascript">              <span class="keyword">this</span>.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(<span class="keyword">this</span>.value.length &gt; max)&#123;</span></span><br><span class="line"><span class="javascript">                  <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.substring(<span class="number">0</span>,max);</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="comment">//use</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#mytextarea'</span>).maxLength(<span class="number">10</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="解析-json-数据时报-parseError-错误"><a href="#解析-json-数据时报-parseError-错误" class="headerlink" title="解析 json 数据时报 parseError 错误"></a>解析 json 数据时报 parseError 错误</h3><p>jQuery 在 1.4 版本后，采用了更为严格的 json 解析方式，即所有内容都必须要有双引号，如果升级 jQuery 版本后，ajax 加载 json 报错，有可能就是这个原因。比如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.4之前版本，key没引号，这样没问题</span></span><br><span class="line">&#123;</span><br><span class="line">  key:"coco",</span><br><span class="line">  status:"0"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但升级成jQuery1.4后，都必须加上双引号，格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"key"</span>:<span class="string">"coco"</span>,</span><br><span class="line">  <span class="attr">"status"</span>:<span class="string">"0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从元素中除去-HTML"><a href="#从元素中除去-HTML" class="headerlink" title="从元素中除去 HTML"></a>从元素中除去 HTML</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">$.fn.stripHtml = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">　<span class="keyword">var</span> regexp = <span class="regexp">/&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi</span>; </span></span><br><span class="line"><span class="javascript">　<span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">  　$(<span class="keyword">this</span>).html( $(<span class="keyword">this</span>).html().replace(regexp,<span class="string">''</span>) ); </span></span><br><span class="line">　&#125;);</span><br><span class="line"><span class="javascript">　<span class="keyword">return</span> $(<span class="keyword">this</span>); </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;)(jQuery); </span><br><span class="line"><span class="javascript"><span class="comment">//用法： </span></span></span><br><span class="line"><span class="javascript">$(<span class="string">'div'</span>).stripHtml(); </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展-String-对象的方法"><a href="#扩展-String-对象的方法" class="headerlink" title="扩展 String 对象的方法"></a>扩展 String 对象的方法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span> &gt;</span>check<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $.extend(<span class="built_in">String</span>.prototype, &#123;</span></span><br><span class="line"><span class="javascript">  isPositiveInteger:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[1-9]\d*$/</span>).test(<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isInteger:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^\d+$/</span>).test(<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isNumber: <span class="function"><span class="keyword">function</span>(<span class="params">value, element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^-?(?:\d+|\d&#123;1,3&#125;(?:,\d&#123;3&#125;)+)(?:\.\d+)?$/</span>).test(<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  trim:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/(^\s*)|(\s*$)|\r|\n/g</span>, <span class="string">""</span>);</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  trans:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/&amp;lt;/g</span>, <span class="string">'&lt;'</span>).replace(<span class="regexp">/&amp;gt;/g</span>,<span class="string">'&gt;'</span>).replace(<span class="regexp">/&amp;quot;/g</span>, <span class="string">'"'</span>);</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  replaceAll:<span class="function"><span class="keyword">function</span>(<span class="params">os, ns</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(os,<span class="string">"gm"</span>),ns);</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  skipChar:<span class="function"><span class="keyword">function</span>(<span class="params">ch</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="keyword">this</span> || <span class="keyword">this</span>.length===<span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="string">''</span>;&#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="keyword">this</span>.charAt(<span class="number">0</span>)===ch) &#123;<span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="number">1</span>).skipChar(ch);&#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">this</span>;</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isValidPwd:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^([_]|[a-zA-Z0-9])&#123;6,32&#125;$/</span>).test(<span class="keyword">this</span>)); </span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isValidMail:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^\w+((-\w+)|(\.\w+))*\@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/</span>).test(<span class="keyword">this</span>.trim()));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isSpaces:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i+=<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ch = <span class="keyword">this</span>.charAt(i);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ch!=<span class="string">' '</span>&amp;&amp; ch!=<span class="string">"\n"</span> &amp;&amp; ch!=<span class="string">"\t"</span> &amp;&amp; ch!=<span class="string">"\r"</span>) &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isPhone:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/(^([0-9]&#123;3,4&#125;[-])?\d&#123;3,8&#125;(-\d&#123;1,6&#125;)?$)|(^\([0-9]&#123;3,4&#125;\)\d&#123;3,8&#125;(\(\d&#123;1,6&#125;\))?$)|(^\d&#123;3,8&#125;$)/</span>).test(<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isUrl:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-z]+:\/\/([a-zA-Z0-9\-\.]+)([-\w .\/?%&amp;=:]*)$/</span>).test(<span class="keyword">this</span>));</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  isExternalUrl:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">this</span>.isUrl() &amp;&amp; <span class="keyword">this</span>.indexOf(<span class="string">"://"</span>+<span class="built_in">document</span>.domain) == <span class="number">-1</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(   $(<span class="string">"input"</span>).val().isInteger()  );</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中国国内 JavaScript 圈的现状如何]]></title>
      <url>https://jiechengyang.github.io/2016/11/18/china-javascript-environment/</url>
      <content type="html"><![CDATA[<p id="div-border-top-purple"><span style="color:red;">探讨核心：</span> 我们不编写代码，我们只是国外优秀框架的搬运工。</p>

<p><img src="/images/javascript-environment-1.jpg" alt></p>
<hr>
<a id="more"></a>
<p id="div-border-left-green" style="position:relative; width:80%;margin-left:10%;">现状么<br>二五八万忙着造轮子步道<br>小白忙着加群拜山头<br>还有几个默默钻研又不为人知的<br>浮躁，自我，没劲<br>有天 leader 抽烟吹逼时候说：国内这些前端啊，多数靠的是名声，写点东西造个轮子，参加一下活动吹吹逼，建个群拉个山头搞一帮小弟，等公司挖了当上leader就算升天了<br>国内 star 最多的没记错是NW吧，噢，人家是C艹分类下的<br>玻璃心洗洗睡吧 <i class="fa fa-twitter fa-3x" style="position:absolute; top:5px; left:-10%;color:#2780e3;"></i></p>

<hr>
<p id="div-border-right-yellow" style="position:relative; width:80%;margin-left:10%;">　　只不过很多开发者停留在外来的和尚会念经阶段。如果很多老外都在用你的技术，国内的名博上写上一篇你的文章表扬一下，国内脑残粉扎堆严重。<br>　　放大些来看，不只前端，其他行业的观念也是如此。<br>　　另外，国内开源心态还不成熟，拿来主义倾向严重。遇到问题，你不帮 ta 解决问题你做的技术就是无用论的不在少数。使得很多开发人员认为做这样的开源简直就是做雷锋，没什么意义，所以很多牛人独善其身的不少。<br>　　认为开源的技术就是无 bug ，产品，是完美，否则你就不要开，这种扯蛋的心态的人也很多。<i class="fa fa-github fa-3x" style="position:absolute; top:5px; right:-10%;color:#9954bb;"></i></p>

<hr>
<p id="div-border-left-blue" style="position:relative; width:80%;margin-left:10%">　　有个东西叫KPI的好吗，你成天在公司，不折腾点东西怎么算KPI，怎么分奖金?<br>为了自身业务和KPI需求，在大点的公司，是肯定有自己的框架的,虽然往往里面充满了来自jquery啊prototypejs等等类库或者框架的几乎一样的代码，甚至在自身需求上还剪掉了一些通用方法，用开发者的话说，这个太臃肿了，我的简洁，然后慢慢的，功能加上来，文件也越来越大了，最后也都趋于跟其他已经使用广泛的类库或者框架一致…<br>　　在量的堆积下，国内的开源东西也凸显了不少好用的，比如fis、eccharts、sea、至于kissy之流咱就忽略吧，毕竟可能是自己的业务需求嘛，虽然文档写的好烂,领导升职了，后续也没人搞了….<br>　　另外还有一个问题，国内很多框架什么的，核心就一个人，在工作繁忙的时候，bug也就没有精力去修复,框架能存在多久，是个问题…有时候在群里都有人宣传自己的框架的，说不定一两年后，人都转行了，之前的框架呢？会有人接手？悄无声息死掉的框架，大把的。<i class="fa fa-laptop fa-3x" style="position:absolute; top:5px; left:-11%;"></i></p>

<hr>
<p id="div-border-right-red" style="position:relative;width:80%;margin-left:10%;">确实搬运了不少国外牛人的框架，但是我也要说一句吐槽的话【bug真特么的多，屁股还要自己擦】<br><br>水平不够只有搬运，擦屁股才是个技术活。<i class="fa fa-weixin fa-3x" style="position:absolute; top:5px; right:-11%;color:#5cb85c;"></i></p>

<hr>
<p id="div-border-left-purple" style="position:relative; width:80%;margin-left:10%;">　　国内其实是有不少在做框架开发或者库开发的，包括BAT新浪网易等等，只是这些框架多数主要围绕自身业务做的，在加上文档、封闭性等等原因其它公司不太适合去用。比如当年做的还不错的seajs，从前端的设计思路和实现上都很简洁明了，只是当时它们要支持自己的复杂业务搞了一套繁琐的路径配置逻辑结果就让人比较头疼了。<br>　　所以我觉得最重要的原因还是环境问题，没有包容、协作、共赢的生态环境人们的思维就会局限在谋求自身的利益，而不是整体价值的最大化。我倒是觉得做搬运工也没什么丢人的，只能说我们条件还不具备，能给出一些有用的反馈也算是有价值的事情了。<i class="fa fa-youtube fa-3x" style="position:absolute; top:5px; left:-10%;color:#df3e3e;"></i></p>

<hr>
<p id="div-border-right-green" style="position:relative;width:80%;margin-left:10%;">开源不分国界，私以为在这个时代还纠结于国内外，纠结于自主知识产权，纠结于国人当自强的都是莫名其妙的民族主义在作祟。<i class="fa fa-tripadvisor fa-3x" style="position:absolute;top:5px;right:-12%;color:#f0ad4e;"></i></p>

<hr>
<p id="div-border-left-yellow" style="position:relative;width:80%;margin-left:10%;">这不是民族主义，这是圈子问题。你的圈子里没有牛人能做出这些东西，这就是差距。国内圈子要是和湾区的交流跟加拿大人一样方便频繁肯定没人说这话。<i class="fa fa-stack-overflow fa-3x" style="position:absolute; top:5px; left:-10%;color:#2780e3;"></i></p>

<hr>
<p id="div-border-right-blue" style="position:relative;width:80%;margin-left:10%;">　　我想问的是那些自己发明轮子的同行们，Backbone.js、AngularJS、jQuery、RequireJS、Bower、Grunt、Yomen 等等无数的开源框架和库以及整个开源社区组成的前端开发生态圈的各种免费解决方案们，到底无法解决工作当中的哪些实际问题，以至于要不停的重复发明轮子，而且还是方的轮子，难道只是为了秀肌肉？或者在各种场合做 talk？<i class="fa fa-html5 fa-3x" style="position:absolute; top:5px; right:-10%; color:#df3e3e;"></i></p>

<hr>
<p id="div-border-left-red" style="position:relative;width:80%;margin-left:10%;">国内某圈子都是国外技术的搬运工不可怕，可怕的是几个高票答案里那股反智主义倾向。<i class="fa fa-weibo fa-3x" style="position:absolute; top:5px; left:-11%;color:#f90;"></i></p>

<hr>
<p id="div-border-right-purple" style="position:relative;width:80%;margin-left:10%;">有优秀的轮子为什么不拿来用？<br>实际上这并不只是国内JS圈的情况，甚至不只是JS圈的情况，其实世界上大多数程序员都是优秀的搬运工啊XD。<i class="fa fa-qq fa-3x" style="position:absolute; top:5px; right:-10%; color:#2780e3;"></i></p>

<hr>
<p id="div-border-left-green" style="position:relative;width:80%;margin-left:10%;">谢邀。我工作中并不用js，所以对于js圈的话并不是很熟悉。题主说国内只是优秀库的搬运工，其实对于这句话我觉得应该客观对待，确实很多前端都是在使用国外的优秀库，比如boostrap等，但是会用与能用是两个不同的概念，会用意味着肯定是有pr的，会用的人水平也应该是肯定的。而且国内也有非常多的优秀js库，比如老赵的wind.js，淘宝的kissy等，再看诸如淘宝，腾讯，360等前端团队牛人泛多，他们是绝对有能力写出题主所定义的优秀库的，有能力会用而且会改造现有的优秀库其实力也不是一般的。所以对于是否是国外优秀库的搬运工，这里应该不存在绝对的定论，理性看待这个问题，至少鄙人非常乐观。<i class="fa fa-android fa-3x" style="position:absolute; top:5px; left:-11%; color:#5cb85c;"></i></p>

<hr>
<p id="div-border-right-yellow" style="position:relative;width:80%;margin-left:10%;">　　其实我刚入行的时候，真的很认真的去听所有国内的 talk，想听到他们为什么做这样的库、做那样的框架，而不是使用开源的解决方案，目前为止，没听到有说服力的理由。<br>　　很多答案都提到了国内的几个优秀开源库，当然前端圈子里面优秀的开源库很多，但目之所及，更多的是照猫画虎反类犬，至于哪些经典案例，我还是怕得罪同行的，就不说了。<br>　　我真的希望能和同行们一起做点别人没做过的库和框架，解决一些现在没人解决的问题，改善一下这种浮躁的风气。<br><br>所以这个评价算是很中肯了，至少我会选择更务实的同事一起工作。<i class="fa fa-apple fa-3x" style="position:absolute; top:5px; right:-10%; color:#555;"></i></p>

<hr>
<p id="div-border-left-blue" style="position:relative;width:80%;margin-left:10%;">　　我匿名是怕得罪同行，毕竟还要混饭吃。但是替他们说话的人还匿名恐怕是中枪了吧？<br>　　Gulp 和 Grunt 用不同的方式解决同一个问题，并且各有千秋，但请别告诉我你们发明的轮子比人家的好用。没有人会反对创新和自主创造，反对的是用同一个姿势吃人家剩下的东西。<br>　　就算是同样的东西，你能说出 Bootstrap 和 GWSK 哪个更好吗，恐怕是同样好吧？但请别说 jQuery 和 XX 板，RequireJS 和 XXXJS 一样好用。你当然也可以反驳说如果不做永远都无法超越，那么首先请你做的至少和人家一样好了以后再到处去布道去秀，另外我始终不觉得超越是什么伟大到值得拿出来说的目的。作为一个工程师，我只想做出真正有用、用户喜欢的产品，对于我所用的框架到底是中国人开发的还是外国人开发的，对不起我不 care，如果你说这叫反智我只能呵呵了。<i class="fa fa-chrome fa-3x" style="position:absolute; top:5px; left:-10%;color:#f0ad4e;"></i></p>

<hr>
<p id="div-border-right-red" style="position:relative;width:80%;margin-left:10%;">　　我对这么多答案中表现出来的对于浪费公司资源去做完全无意义的事情然后还到处去显摆并作为 promotion 资本这件事情表现出来的漠然感到震惊。<br>　　这个世界上从来都不缺想让世界变得更好的人，特别是工程师群体，但可惜的是出于某些邪恶目的而重复发明轮子的人也不少。我不否定国内有优秀的轮子，并且敬佩能做出好的开源项目的人，但我敬佩你不会是因为你有个「中国工程师」的定语。<br>　　要强调的的是国内前端圈子里面非常流行的「为了做而做，做的是完全一样的东西还没人家好，然后还到处去显摆」这种行为真的是令人恶心。<i class="fa fa-yelp fa-3x" style="position:absolute; top:5px; right:-10%;color:#2780e3;"></i></p>

<hr>
<p id="div-border-left-purple" style="position:relative;width:80%;margin-left:10%;">排名第一的答案的外链中有一句话：“我以前就一直说：我们离最先进的技术的差距只有半年。”<br>　　其实这已经很说明问题了，离最先进的技术有差距（不管是半年还是半个月），这说明国内做的东西不是原创的，而是在重复造轮子（有些有微创新，当然我相信也有原创的，但应该非常少）<br>　　比如 ueditor，国外都有那么强大的编辑器了，如果照着它都不能造一个轮子出来，那只能怀疑造轮子的人水平有问题。我记得 ueditor 团队还制作了个视频宣讲 ueditor，其中说到xxx还用了很nb的算法（二分查找），不知道的人还真以为是自己想出来的，回来一看 fckeditor，代码都几乎一模一样（当然 ueditor 本身是很不错的，比较符合国情）。<br>　　再说 SeaJS，CMD 是神马啊，它真的很C（ommon）吗？SeaJS 模块难道不是异步模块（AMD）吗？命名上就把人搞晕了。怎么解释还需要修改 jQuery 源代码的问题？jQuery 会来兼容 SeaJS 吗？你们知道有多少人兴致勃勃地用了 SeaJS 后最后又切换到 requierJS 吗？<br>　　再说下，国内的技术人员不但不团结，还互相讥讽，我相信这一点玉伯深有体会。大家可以去看下 SeaJS 的源代码贡献者，除了玉伯你们都还认识谁？SeaJS 团队发布了 SPM 工具，遭受了多少的嘲笑啊！虽然 SPM 最为人诟病。<br>　　整天张口闭口说开源的那些人，怎么都觉得 SeaJS 已经很完美了？<br>　　不是不用国内的东西，而是用过后觉得很失望，要文档没文档，说改就改不够稳定。并且据我所知，很多项目的核心开发就一个人，我能相信这东西靠谱吗？我可要为我整个公司负责啊，解决业务需求是我的首要目标，出了 bug 我可担当不起啊。<br>　　重复造轮子没问题，但你造个方的轮子或者和不符合国际标准的轮子还到处得瑟让你的同事或者业界朋友来用，你就是来捣乱的！<br>　　语气重了点，希望大家见谅！<i class="fa fa-opencart fa-3x" style="position:absolute; top:5px; left:-11%;color:#df3e3e;"></i></p>

<hr>
<p id="div-border-right-green" style="position:relative;width:80%;margin-left:10%;">中小公司缺乏强力统一的方向和规范，很多都只是搬运工，没有深入。大公司如bat之类的会有自己的体系，也是众多工程师的学习楷模。<i class="fa fa-css3 fa-3x" style="position:absolute; top:5px; right:-10%;color:#9954bb;"></i></p>





<p><a href="https://www.zhihu.com/question/24317445" target="_blank" rel="noopener">原文</a></p>
]]></content>
      
        <categories>
            
            <category> 综合 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> essay </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Sass 教程]]></title>
      <url>https://jiechengyang.github.io/2016/10/23/sass/</url>
      <content type="html"><![CDATA[<p><span id="inline-blue" style="font-size:100%;border-radius:3px;">Sass</span>： (Syntactically Awesome StyleSheets)</p>
<h1 id="sass简介"><a href="#sass简介" class="headerlink" title="sass简介"></a>sass简介</h1><p>来自于官网的简介：<br>Sass is the most mature, stable, and powerful professional grade CSS extension language in the world.</p>
<font color="red"> Sass 是世界上最成熟的，稳定的，功能强大的专业级 CSS 扩展语言。</font>

<a id="more"></a>
<h1 id="sass-安装"><a href="#sass-安装" class="headerlink" title="sass 安装"></a>sass 安装</h1><p>因为 sass 依赖 ruby 环境，所以装 sass 之前先确认安装了 ruby .<br>在安装的时候，请勾选 Add Ruby executables to your PATH 这个选项，添加环境变量，不然以后使用编译软件的时候会提示找不到 ruby 环境.<br><img src="http://i1.piimg.com/567571/3a876fb3bb575d25.png" alt></p>
<p>安装完 ruby 之后，在开始菜单中，打开我们的命令行，输入<br><code>ruby -v</code></p>
<p><img src="http://i1.piimg.com/567571/e5795e583371ce6d.png" alt><br>那么我们的 ruby 就安装成功了。</p>
<p>然后直接在命令行中输入<br><code>gem install sass</code><br>按回车键确认，等待一段时间就会提示你 sass 安装成功。</p>
<p>如果要安装 beta 版本的，可以在命令行中输入<br><code>gem install sass --pre</code></p>
<p>最近因为墙的比较厉害，如果你没有安装成功，那么请参考下面的淘宝的 RubyGems 镜像安装 sass ，如果成功则忽略。<br>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过 gem sources 命令来配置源，先移除默认的 <a href="https://rubygems.org" target="_blank" rel="noopener">https://rubygems.org</a> 源，然后添加淘宝的源 <code>https://ruby.taobao.org/</code> ，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入 sass 安装命令 gem install sass 了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://ruby.taobao.org/</span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<p>如果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https://ruby.taobao.org</span><br></pre></td></tr></table></figure></p>
<p>则表示镜像替换成功，下一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install sass</span><br></pre></td></tr></table></figure></p>
<p>按回车键确认，等待一段时间就会提示你 sass 安装成功。</p>
<p>如果你熟悉 git 命令的话，你还可以从 sass 的 Git repository 来安装，git 的命令行为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/nex3/sass.git</span><br><span class="line">cd sass</span><br><span class="line">rake install</span><br></pre></td></tr></table></figure></p>
<h1 id="如何升级-sass-版本"><a href="#如何升级-sass-版本" class="headerlink" title="如何升级 sass 版本"></a>如何升级 sass 版本</h1><p>我们可以使用命令 <code>gem update sass</code> 来升级我们的 sass 版本。</p>
<p>如果想要安装sass的某一特定版本，命令行为<br><code>gem install sass --version=3.3.0</code></p>
<p>如果想要删除sass的某一特定版本，命令行为<br><code>gem uninstall sass --version=3.3.0</code></p>
<p>卸载sass,命令行为<br><code>gem uninstall sass</code></p>
<p>查看sass版本的命令行为<br><code>sass -v</code></p>
<p>查看ruby安装的所有程序包，命令语句为 <code>gem list</code> 。</p>
<h1 id="sass-命令"><a href="#sass-命令" class="headerlink" title="sass 命令"></a>sass 命令</h1><p>安装成功 sass 以后，我们来写个 demo 测试一下：<br>创建一个 <code>style.scss</code> 文件：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">14px</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单文件转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss style.css</span><br></pre></td></tr></table></figure></p>
<p>单文件监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --watch style.scss:style.css</span><br></pre></td></tr></table></figure></p>
<p>文件夹监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --watch sassFileDirectory:cssFileDirectory</span><br></pre></td></tr></table></figure></p>
<p>css 文件转成 sass/scss 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sass-convert style.css style.sass</span><br><span class="line">sass-convert style.css style.scss</span><br></pre></td></tr></table></figure></p>
<h2 id="sass-命令配置选项"><a href="#sass-命令配置选项" class="headerlink" title="sass 命令配置选项"></a>sass 命令配置选项</h2><p>运行命令行帮助文档，可以获得所有的配置选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass -h</span><br></pre></td></tr></table></figure></p>
<p>配置选项 <code>--style</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss:style.css --style compact</span><br></pre></td></tr></table></figure></p>
<p><code>--style</code> 表示解析后的 css 是什么格式，有四种取值分别为：expanded ，nested ，compact ，compressed 。</p>
<p>配置选项 <code>--sourcemap</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss:style.css --sourcemap</span><br></pre></td></tr></table></figure></p>
<p><code>--sourcemap</code> 表示开启 sourcemap 调试。开启 sourcemap 调试后，会生成一个后缀名为 .css.map 文件。</p>
<p>配置选项 <code>--debug-info</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss:style.css --debug-info</span><br></pre></td></tr></table></figure></p>
<p><code>--debug-info</code> 表示开启 debug 信息，升级到 3.3.0 之后因为 sourcemap 更高级，这个 debug-info 就不太用了。</p>
<h1 id="sass语法"><a href="#sass语法" class="headerlink" title="sass语法"></a>sass语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在介绍 sass 语法之前，最有必要的是先来了解一下 sass 中的注释。<br>sass 有两种注释方式，一种是标准的 css 注释方式 <code>/* */</code>，另一种则是 <code>//</code> 双斜杆形式的单行注释，不过这种单行注释不会被转译出来，也就是说 <code>//</code> 这种注释不会转译到编译后的 css 文件中。</p>
<p>需要说明的是：如果你的注释中有中文的话，请务必在 scss 文件开头加上：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"UTF-8"</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果没有这个的话，会报错。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>sass 的变量必须是 $ 开头，后面紧跟变量名，而变量值和变量名之间就需要使用冒号(：)分隔开（就像 CSS 属性设置一样），如果值后面加上 !default 则表示默认值。<br>普通变量<br>定义之后可以在全局范围内使用。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">12px</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h3><p>sass 的默认变量仅需要在值后面加上 <code>!default</code> 即可。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="variable">$baseLineHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="variable">$baseLineHeight</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">2</span>;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="variable">$baseLineHeight</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个相当于给 $baseLineHeight 设置了一个默认值，如果你想重新设置的话，可以再写一个 $baseLineHeight 的属性值来覆盖它。</p>
<h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><p>一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下等则必须要以 <code>#{$variables}</code> 形式使用。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$borderDirection</span>: top !default;</span><br><span class="line"><span class="variable">$baseFontSize</span>: <span class="number">12px</span> !default;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用于 class 和属性</span></span><br><span class="line"><span class="selector-class">.border-</span>#&#123;<span class="variable">$borderDirection</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>-#&#123;<span class="variable">$borderDirection</span>&#125;: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//应用于复杂的属性值</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>:#&#123;<span class="variable">$baseFontSize</span>&#125;/#&#123;<span class="variable">$baseLineHeight</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个地方我们如果不用 <code>#{$variables}</code> 形式的话，那么结果中 body 的样式就是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这显然不是我们想要的。</p>
<h3 id="多值变量"><a href="#多值变量" class="headerlink" title="多值变量"></a>多值变量</h3><p>多值变量分为 list 类型和 map 类型，简单来说 list 类型有点像 js 中的数组，而 map 类型有点像 js 中的对象。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list 数据可通过空格，逗号或小括号分隔多个值，可用 nth($var,$index) 取值。关于 list 数据操作还有很多其他函数如 <code>length($list)</code> ， <code>join($list,$list2,[$separator])</code> ， <code>append($list,$value,[$separator])</code> 等。</p>
<p>定义<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="variable">$px</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="variable">$px</span>: <span class="number">5px</span> <span class="number">10px</span>, <span class="number">20px</span> <span class="number">30px</span>;</span><br><span class="line"><span class="variable">$px</span>: (<span class="number">5px</span> <span class="number">10px</span>) (<span class="number">20px</span> <span class="number">30px</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$linkColor</span>: <span class="number">#08c</span> <span class="number">#333</span> !default;<span class="comment">//第一个值为默认值，第二个鼠标滑过值</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:nth(<span class="variable">$linkColor</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:nth(<span class="variable">$linkColor</span>,<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#08c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 数据以 key和 value 成对出现，其中 value 又可以是 list 。格式为： <code>$map:(key1: value1,key2:value2,key3:value3);</code> 。可通过 <code>map-get($map,$key)</code> 取值。关于map数据还有很多其他函数如 <code>map-merge($map1,$map2)</code> ， <code>map-keys($map)</code> ， <code>map-values($map)</code> 等。</p>
<p>定义<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$heading</span>: (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>);</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$headings</span>: (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>);</span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in <span class="variable">$headings</span> &#123;</span><br><span class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在变量值后面加上 !global 即为全局变量。<br>在选择器中声明的变量会覆盖外面全局声明的变量。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">12px</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="variable">$fontSize</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启用global之后的机制</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fontSize</span>: <span class="number">12px</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="variable">$fontSize</span>: <span class="number">14px</span> !global;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontSize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面的机制对比就会发现默认在选择器里面的变量为局部变量，而只有设置了 !global 之后才会成为全局变量。</p>
<h2 id="嵌套-Nesting"><a href="#嵌套-Nesting" class="headerlink" title="嵌套(Nesting)"></a>嵌套(Nesting)</h2><p>sass 的嵌套包括两种：一种是选择器的嵌套；另一种是属性的嵌套。</p>
<h3 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h3><p>所谓选择器嵌套指的是在一个选择器中嵌套另一个选择器来实现继承，从而增强了 sass 文件的结构性和可读性。<br>在选择器嵌套中，可以使用 <code>&amp;</code> 表示父元素选择器</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#top_nav</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-transform</span>: capitalize;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#ddd</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性嵌套"><a href="#属性嵌套" class="headerlink" title="属性嵌套"></a>属性嵌套</h3><p>所谓属性嵌套指的是有些属性拥有同一个开始单词，如border-width，border-color都是以border开头。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fakeshadow</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">    style: solid;</span><br><span class="line">    <span class="attribute">left</span>: &#123;</span><br><span class="line">      width: <span class="number">4px</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#888</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">right</span>: &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">2px</span>;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然这个只是属性嵌套的一个例子，在实际中这样来写 <code>border</code> 的样式或许有些复杂了，但在属性嵌套在别的地方肯定用得到。</p>
<h2 id="at-root"><a href="#at-root" class="headerlink" title="@at-root"></a>@at-root</h2><p>sass3.3.0 中新增的功能，用来跳出选择器嵌套的。默认所有的嵌套，继承所有上级选择器，但有了这个就可以跳出所有上级选择器。</p>
<h3 id="普通跳出嵌套"><a href="#普通跳出嵌套" class="headerlink" title="普通跳出嵌套"></a>普通跳出嵌套</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*没有跳出*/</span></span><br><span class="line"><span class="selector-class">.parent-1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*单个选择器跳出*/</span><br><span class="line">.parent-<span class="number">2</span> &#123;</span><br><span class="line">  color: <span class="number">#f00</span>;</span><br><span class="line">  <span class="keyword">@at-root</span> .child &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*多个选择器跳出*/</span></span><br><span class="line"><span class="selector-class">.parent-3</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    <span class="selector-class">.child1</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.child2</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认 <code>@at-root</code> 只会跳出选择器嵌套，而不能跳出 <code>@media</code> 或 <code>@support</code> ，如果要跳出这两种，则需要使用 <code>@at-root(without:media)</code> ，<code>@at-root(without:support)</code> 。这个语法的关键词有四个： <code>all</code> （表示所有），<code>true</code>（表示常规CSS）， <code>media</code>（表示media）， ‘support’（表示support，因为 <code>@support</code> 目前还无法广泛使用）。我们默认的 <code>@at-root</code> 其实就是 <code>@at-root(without:rule)</code> 。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-class">.parent1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> .child1 &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200px</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//跳出media嵌套，父级有效</span><br><span class="line">@media print &#123;</span><br><span class="line">  .parent2 &#123;</span><br><span class="line">    color: <span class="number">#f00</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> (without:media) &#123;</span><br><span class="line">      <span class="selector-class">.child2</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跳出media和父级</span></span><br><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-class">.parent3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> (without:all) &#123;</span><br><span class="line">      <span class="selector-class">.child3</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@at-root</code> 与 <code>&amp;</code> 配合使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> .parent &amp; &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#f00</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应用于<code>@keyframe</code><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attribute">animation</span>: motion <span class="number">3s</span> infinite;</span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    <span class="keyword">@keyframes</span> motion &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">    ...   </span><br><span class="line">    <span class="attribute">animation</span>: motion <span class="number">3s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> motion &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我认为 <code>@at-root</code> 应用于 <code>@keyframe</code> 或许是 <code>@at-root</code> 最好的实践。<br>跳出嵌套，我们为什么要用 <code>@at-root</code> 来实现呢？我们完全可以在写样式的时候，不使用嵌套的写法。<br>但是 <code>@keyframe</code> 就不一样了，这个动画应用于当前选择器，所以把动画样式写入这个选择器的结构里，方便修改与查看。<br>相比于之前在 css 中使用 @keyframe 来定义动画，然后在元素中调用，如果一个文件中 @keyframe 比较多的话，在我们想要调用动画的时候，动画与元素之间的关联性比较差。</p>
<h2 id="混合-mixin"><a href="#混合-mixin" class="headerlink" title="混合(mixin)"></a>混合(mixin)</h2><p>sass 中使用 <code>@mixin</code> 声明混合，可以传递参数，参数名以 $ 符号开始，多个参数以逗号分开，也可以给参数设置默认值，声明的 @mixin 通过 @include 来调用。</p>
<h3 id="无参数mixin"><a href="#无参数mixin" class="headerlink" title="无参数mixin"></a>无参数mixin</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> center-block &#123;</span><br><span class="line">  <span class="attribute">margin</span>: &#123;</span><br><span class="line">    left: auto;</span><br><span class="line">    <span class="attribute">right</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> center-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:auto;</span><br><span class="line">    <span class="attribute">margin-right</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="有参数mixin"><a href="#有参数mixin" class="headerlink" title="有参数mixin"></a>有参数mixin</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> opacity(<span class="variable">$opacity</span>: <span class="number">50</span>) &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="variable">$opacity</span> / <span class="number">100</span>;</span><br><span class="line">  <span class="attribute">filter</span>: alpha(opacity=<span class="variable">$opacity</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.opacity</span>&#123;</span><br><span class="line">  <span class="keyword">@include</span> opacity; <span class="comment">//参数使用默认值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.opacity-80</span>&#123;</span><br><span class="line">  <span class="keyword">@include</span> opacity(<span class="number">80</span>); <span class="comment">//传递参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多个参数mixin"><a href="#多个参数mixin" class="headerlink" title="多个参数mixin"></a>多个参数mixin</h3><p>调用时可直接传入值，如 <code>@include</code> 传入参数的个数小于 <code>@mixin</code> 定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> horizontal-line(<span class="variable">$border</span>:<span class="number">1px</span> dashed <span class="number">#ccc</span>,<span class="variable">$padding</span>:<span class="number">10px</span>) &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="variable">$border</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="variable">$padding</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="variable">$padding</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.imgtext-h</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> horizontal-line(<span class="number">1px</span> solid <span class="number">#ccc</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.imgtext-h-product</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> horizontal-line(<span class="variable">$padding</span>:<span class="number">15px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.imgtext-h</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#cccccc</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.imgtext-h--product</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#cccccc</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多组值参数mixin"><a href="#多组值参数mixin" class="headerlink" title="多组值参数mixin"></a>多组值参数mixin</h3><p>如果一个参数可以有多组值，如 <code>box-shadow</code> 、<code>transition</code> 等，那么参数则需要在变量后加三个点表示，如 <code>$variables...</code> 。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//box-shadow可以有多组值，所以在变量参数后面添加...</span></span><br><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadow</span>...) &#123;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="variable">$shadow</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="variable">$shadow</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="keyword">@include</span> box-shadow (<span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>),<span class="number">0</span> <span class="number">3px</span> <span class="number">3px</span> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>),<span class="number">0</span> <span class="number">4px</span> <span class="number">4px</span> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="content"><a href="#content" class="headerlink" title="@content"></a>@content</h2><p>@content 可以用来解决 css3 的 @media 等带来的问题。它可以使 @mixin 接受一整块样式，接受的样式从 @content 开始。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> max-screen(<span class="variable">$res</span>) &#123;</span><br><span class="line">  <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (max-width:<span class="variable">$res</span>) &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> max-screen(<span class="number">480px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PS：@mixin 通过 @include 调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从 3.2.0 版本以后，建议传递参数的用 @mixin ，而非传递参数的使用下面的继承 % 。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>sass 中，选择器继承可以让选择器继承另一个选择器的所有样式，并联合声明。使用选择器的继承，要使用关键词 @extend ，后面紧跟需要继承的选择器。</p>
<p>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#ff9aa9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.speaker</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> h1;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-class">.speaker</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="number">#ff9aa9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.speaker</span>&#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，选择器继承生成的样式不是拷贝的形式，而是以联合声明的方式存在的。</p>
<h3 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节"></a>继承的工作细节</h3><p>关于 @extend 有两个要点你应该知道：</p>
<p>1、跟混合器相比，继承生成的 css 代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。如果你非常关心你站点的速度，请牢记这一点。<br>举个例子，使用混合器的时候：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> border-colors &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo1</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-colors;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo2</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> border-colors; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它生成的 <code>css</code> 如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用继承的时候：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo2</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .demo1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它生成的 <code>css</code> 如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo1</span>, <span class="selector-class">.demo2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的 css 体积更小。</p>
<p>2、继承遵从 css 层叠的规则。当两个不同的 css 规则应用到同一个 html 元素上时，并且这两个不同的 css 规则对同一属性的修饰存在不同的值， css 层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</p>
<p>混合器本身不会引起 css 层叠的问题，因为混合器把样式直接放到了 css 规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。</p>
<h3 id="使用继承的最佳实践"><a href="#使用继承的最佳实践" class="headerlink" title="使用继承的最佳实践"></a>使用继承的最佳实践</h3><p>通常使用继承会让你的 css 美观、整洁。因为继承只会在生成 css 时复制选择器，而不会复制大段的 css 属性。但是如果你不小心，可能会让生成的 css 中包含大量的选择器复制。<br>避免这种情况出现的最好方法就是不要在 css 规则中使用后代选择器（比如 .foo .bar）去继承 css 规则。如果你这么做，同时被继承的 css 规则有通过后代选择器修饰的样式，生成 css 中的选择器的数量很快就会失控。<br>例如：<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bip</span> <span class="selector-class">.baz</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.foo</span> <span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的css如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bip</span> <span class="selector-class">.baz</span>, <span class="selector-class">.bip</span> <span class="selector-class">.foo</span> <span class="selector-class">.bar</span>, <span class="selector-class">.foo</span> <span class="selector-class">.bip</span> <span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以如果允许，尽可能避免这种用法。<br><strong> 值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。 </strong></p>
<h2 id="占位选择器"><a href="#占位选择器" class="headerlink" title="占位选择器 %"></a>占位选择器 %</h2><p>从 sass 3.2.0 以后就可以定义占位选择器 % 。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了 @extend 去继承相应的样式，都会解析出来所有的样式。占位选择器以 % 标识定义，通过 @extend 调用。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">%ir &#123;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">text-shadow</span>: none;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$lte7</span>:true !default;</span><br><span class="line">%clearfix &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$lte7</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:before</span>,&amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">0</span>/<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="keyword">@extend</span> %ir;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.ir &#123;</span><br><span class="line">  @extend %ir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码，定义了两个占位选择器 <code>%ir</code> 和 <code>%clearfix</code> ，其中 <code>%clearfix</code> 这个没有调用，所以解析出来的css样式也就没有clearfix部分。占位选择器的出现，使css文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的css。<br>ps:在 @media 中暂时不能 @extend ， @media 外的代码片段，以后将会可以。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>sass 定义了很多函数可供使用，当然你也可以自己定义函数，以 @function 开始。sass 的官方函数链接为：<a href="http://sass-lang.com/documentation/Sass/Script/Functions.html" target="_blank" rel="noopener">sass function</a> ，实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以 lighten 减淡和 darken 加深使用最多，其调用方法为 <code>lighten($color,$amout)</code> 和 <code>darken($color,$amount)</code> ，它们的第一个参数都是颜色值，第二个参数都是百分比。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$baseFontSize</span>: <span class="number">10px</span> !default;</span><br><span class="line"><span class="variable">$gray</span>: <span class="number">#ccc</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@function</span> pxToRem(<span class="variable">$px</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$px</span> / <span class="variable">$baseFontSize</span> * <span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$baseFontSize</span>;</span><br><span class="line">  <span class="attribute">color</span>: lighten(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: pxToRem(<span class="number">16px</span>);</span><br><span class="line">  <span class="attribute">color</span>: darken(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 @mixin ，% ，@function 更多说明可参阅：<br><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html" target="_blank" rel="noopener">sass文档</a></p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>sass 具有运算的特性，可以对数值型的 Value（如：数字、颜色、变量等）进行加减乘除四则运算。请注意运算前后请留一个空格，不然会出错。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$baseFontSize</span>: <span class="number">14px</span> !default;</span><br><span class="line"><span class="variable">$baseLineHeight</span>: <span class="number">1.5</span> !default;</span><br><span class="line"><span class="variable">$baseGap</span>: <span class="variable">$baseFontSize</span> * <span class="variable">$baseLineHeight</span> !default;</span><br><span class="line"><span class="selector-class">.balber</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$baseGap</span>;    <span class="comment">//21px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="条件判断及循环"><a href="#条件判断及循环" class="headerlink" title="条件判断及循环"></a>条件判断及循环</h2><h3 id="if判断"><a href="#if判断" class="headerlink" title="@if判断"></a>@if判断</h3><p>@if 可一个条件单独使用，也可以和 @else 结合多条件使用。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$lte7</span>: true;</span><br><span class="line"><span class="variable">$type</span>: monster;</span><br><span class="line"><span class="selector-class">.ib</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="keyword">@if</span> <span class="variable">$lte7</span> &#123;</span><br><span class="line">        *<span class="attribute">display</span>:inline;</span><br><span class="line">        *zoom:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$type</span> == ocean &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if <span class="variable">$type</span> == matador &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if <span class="variable">$type</span> == monster &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的 css 如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ib</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  *<span class="attribute">display</span>: inline;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三目判断"><a href="#三目判断" class="headerlink" title="三目判断"></a>三目判断</h3><p>语法为：<code>if($condition,$if_true,$if_false)</code>。<br>三个参数分别表示：条件，条件为真的值，条件为假的值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(true,1px,2px) =&gt; 1px</span><br><span class="line">if(false,1px,2px) =&gt; 2px</span><br></pre></td></tr></table></figure></p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for 循环有两种形式，分别为：<br><code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 和 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code> 。<br>$i 表示变量，start 表示起始值，end 表示结束值，这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。<br>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">5</span> to <span class="number">7</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-5</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="each循环"><a href="#each循环" class="headerlink" title="each循环"></a>each循环</h3><p>语法为：<code>@each $var in &lt;list or map&gt;</code> 。<br>其中 $var 表示变量，而 list 和 map 表示 list 类型数据和 map 类型数据。sass 3.3.0 新加入了多字段循环和 map 数据循环。</p>
<h4 id="单个字段-list-数据循环"><a href="#单个字段-list-数据循环" class="headerlink" title="单个字段 list 数据循环"></a>单个字段 list 数据循环</h4><p>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$animal-list</span>: puma, sea-slug, egret, salamander;</span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span> in <span class="variable">$animal-list</span> &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'/images/#&#123;$animal&#125;.png'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/images/puma.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/images/sea-slug.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/images/egret.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.salamander-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"/images/salamander.png"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多个字段-list-数据循环"><a href="#多个字段-list-数据循环" class="headerlink" title="多个字段 list 数据循环"></a>多个字段 list 数据循环</h4><p>使用<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$animal-data</span>: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);</span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span>, <span class="variable">$color</span>, <span class="variable">$cursor</span> in <span class="variable">$animal-data</span> &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'/images/#&#123;$animal&#125;.png'</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="variable">$cursor</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/images/puma.png'</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">cursor</span>: default; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/images/sea-slug.png'</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'/images/egret.png'</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span><br><span class="line">  <span class="attribute">cursor</span>: move; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多个字段-map-数据循环"><a href="#多个字段-map-数据循环" class="headerlink" title="多个字段 map 数据循环"></a>多个字段 map 数据循环</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$headings</span>: (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>);</span><br><span class="line"><span class="keyword">@each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in <span class="variable">$headings</span> &#123;</span><br><span class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文介绍了 sass 最基本部分,你可以轻松地使用 sass 编写清晰、无冗余、语义化的 css 。对于 sass 提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。</p>
<p><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html" target="_blank" rel="noopener">sass文档</a><br><a href="http://sass-lang.com/documentation/Sass/Script/Functions.html" target="_blank" rel="noopener">sass函数列表</a><br><a href="https://sass-guidelin.es/zh/" target="_blank" rel="noopener">sass guidelines</a></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> sass </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
